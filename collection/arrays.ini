# DelphiDabbler Code Snippets Database v2
#
# Arrays category file
#
# This file is licensed under the MIT license, copyright © 2020 Peter Johnson,
# https://gravatar.com/delphidabbler

[ArrayToStringList]
DescEx="<p>Copies the elements of string array <var>Strings</var> to string list <var>SL</var>, replacing any existing contents of <var>SL</var>.</p>"
SeeAlso=StringListToArray
Units=Classes
Snip=533.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ByteArraysEqual]
DescEx="<p>Checks if two byte arrays are equal.</p><p>The arrays are equal if they have the same number of elements and elements at the same position in the array are equal.</p>"
SeeAlso=ByteArraysSameStart
Snip=365.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ByteArraysSameStart]
DescEx="<p>Checks if two byte arrays <var>B1</var> and <var>B2</var> are equal for the first <var>Count</var> elements.</p><p>False is returned if any array has less than <var>Count</var> elements.</p><p><var>Count</var> must be &gt;= 1.</p>"
SeeAlso=ByteArraysEqual
Snip=481.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IndexOfByte]
DescEx="<p>Returns the index of the first occurrence of byte <var>B</var> in byte array <var>A</var>, or -1 if <var>B</var> is not in <var>A</var>.</p>"
SeeAlso=LastIndexOfByte
Snip=482.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LastIndexOfByte]
DescEx="<p>Returns the index of the last occurrence of byte <var>B</var> in byte array <var>A</var>, or -1 if <var>B</var> is not in <var>A</var>.</p>"
SeeAlso=IndexOfByte
Snip=483.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StringListToArray]
DescEx="<p>Creates and returns a dynamic string array containing all the strings from the given string list.</p>"
SeeAlso=ArrayToStringList
Units=Classes,Types
Snip=347.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AppendByteArray]
DescEx="<p>Appends array of bytes <var>B2</var> to the end of byte array <var>B1</var>.</p>"
Depends=TBytes
SeeAlso=ConcatByteArrays
Snip=364.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ChopByteArray]
DescEx="<p>Deletes a sequence of bytes from byte array <var>B</var> starting at index <var>Start</var> with length <var>Len</var>.</p><p>If either <var>Start</var> or <var>Len</var> are less than 0 they are taken as zero. If <var>Start</var> is beyond the end of the array or if <var>Len</var> is 0 then the whole array is returned unchanged. If the sequence of bytes to be chopped extends beyond the end of the array it is truncated from <var>Start</var>.</p>"
Depends=TBytes,ConcatByteArrays,SliceByteArray
SeeAlso=SliceByteArray
Snip=366.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CloneByteArray]
DescEx="<p>Makes a copy of an array of bytes.</p>"
Extra="<p>Useful for creating a <var>TBytes</var> array from a constant array or for cloning an existing byte array.</p>"
Depends=TBytes
SeeAlso=AppendByteArray
Snip=367.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ConcatByteArrays]
DescEx="<p>Concatenates two byte arrays <var>B1</var> and <var>B2</var> and returns the resulting array.</p><p>The result is the contents of <var>B1</var> followed by the contents of <var>B2</var>.</p>"
Depends=TBytes,AppendByteArray,CloneByteArray
SeeAlso=AppendByteArray
Snip=368.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PopByteArray]
DescEx="<p>Removes the last element of byte array <var>A</var> and returns the element. The length of <var>A</var> shrinks by one.</p><p><var>A</var> must not be empty.</p>"
Depends=TBytes
SeeAlso=PushByteArray,ShiftByteArray,UnShiftByteArray
Snip=484.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PushByteArray]
DescEx="<p>Pushes byte <var>B</var> onto the end of byte array <var>A</var>. The length of <var>A</var> grows by one.</p>"
Depends=TBytes
SeeAlso=PopByteArray,ShiftByteArray,UnShiftByteArray
Snip=485.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ShiftByteArray]
DescEx="<p>Removes the first element of byte array <var>A</var> and returns the element. The length of <var>A</var> shrinks by one.</p><p><var>A</var> must not be empty.</p>"
Depends=TBytes
SeeAlso=PopByteArray,PushByteArray,UnShiftByteArray
Snip=486.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SliceByteArray]
DescEx="<p>Slices a range of bytes from byte array <var>B</var>, starting at index <var>Start</var> with length <var>Len</var>, and returns the result.</p><p>If either <var>Start</var> or <var>Len</var> are less than 0, they are taken as 0. If <var>Start</var> is beyond the end of the array or if <var>Len</var> is 0 then an empty array is returned. If the sequence of bytes to be sliced extends beyond the end of the array it is truncated from <var>Start</var>.</p>"
Depends=TBytes
SeeAlso=ChopByteArray
Snip=369.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[UnShiftByteArray]
DescEx="<p>Inserts byte <var>B</var> at the beginning of byte array <var>A</var>. The length of <var>A</var> grows by one.</p>"
Depends=TBytes
SeeAlso=PopByteArray,PushByteArray,ShiftByteArray
Snip=487.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TArrayUtils]
Kind=class
DescEx="<p>A method-only advanced record that provides utility methods for working with generic dynamic arrays.</p>"
Units=Generics.Defaults
SeeAlso=IndexOfByte,ByteArraysEqual,ByteArraysSameStart
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Arrays"
Snip=623.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=N
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=Y
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N
