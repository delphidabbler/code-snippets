# DelphiDabbler Code Snippets Database v2
#
# Mathematics category file
#
# This file is licensed under the MIT license, copyright © 2025 Peter Johnson,
# https://gravatar.com/delphidabbler

[AllDigitsDifferent]
DescEx="<p>Checks if all the digits of the given integer are different to each other.</p>"
Extra="<p>An example of an integer with all digits different is 15862.</p>"
SeeAlso=AllDigitsSame
Snip=498.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[AllDigitsSame]
DescEx="<p>Checks if all the digits of the given integer are the same.</p>"
Extra="<p>An example of an integer with all digits the same is 777777.</p>"
SeeAlso=AllDigitsDifferent,RepeatedDigits
Snip=499.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ArraySum_Cardinal]
DisplayName="ArraySum (Cardinal overload)"
DescEx="<p>Returns the sum of all <var>Cardinal</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=636.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Double]
DisplayName="ArraySum (Double overload)"
DescEx="<p>Returns the sum of all <var>Double</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=637.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Extended]
DisplayName="ArraySum (Extended overload)"
DescEx="<p>Returns the sum of all <var>Extended</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=638.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Int64]
DisplayName="ArraySum (Int64 overload)"
DescEx="<p>Returns the sum of all <var>Int64</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=639.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Integer]
DisplayName="ArraySum (Integer overload)"
DescEx="<p>Returns the sum of all <var>Integer</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=640.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Single]
DisplayName="ArraySum (Single overload)"
DescEx="<p>Returns the sum of all <var>Single</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=641.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_UInt64]
DisplayName="ArraySum (UInt64 overload)"
DescEx="<p>Returns the sum of all <var>UInt64</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=642.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[DigitCount]
DescEx="<p>Counts the number of digits in the given integer.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=DigitCount2,DigitCountR,DigitCountBase
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=202.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[DigitCount2]
DescEx="<p>Counts the number of digits in the given integer.</p>"
Extra="<p>Based on code suggested by Don Rowlett.</p>"
Units=Math
SeeAlso=DigitCount,DigitCountR,DigitCountBase
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=204.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[DigitCountR]
DescEx="<p>Counts the number of digits in the given integer using recursion.</p>"
Extra="<p>Contributed by Rubem Nascimento da Rocha.</p>"
SeeAlso=DigitCount,DigitCount2,DigitCountBase
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=417.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Factorial]
DescEx="<p>Calculates the factorial of the given number.</p>"
Extra="<p>Adapted from code contributed by Don Rowlett.</p>"
Snip=231.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[IsRectNormal]
DescEx="<p>Checks if the given rectangle is normalized, i.e. <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>.</p>"
Units=Windows
SeeAlso=NormalizeRect
Snip=124.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MoveRectToOrigin]
DescEx="<p>Translates the give rectangle to the origin.</p><p>The top and left co-ordinates are set to zero and the bottom and right co-ordinates are adjusted accordingly.</p>"
Units=Types
Snip=373.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[NormalizeRect]
DescEx="<p>Normalises the given rectangle so that <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>.</p>"
Extra="<p>Inspired by code published by Marco Cantù in supplementary chapter 22 of Mastering Delphi 5.</p>"
Units=Windows
Depends=ExchangeInt
SeeAlso=IsRectNormal
Snip=125.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[RectArea]
DescEx="<p>Returns the area of the given rectangle.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top.</p>"
SeeAlso=RectHeight,RectSize,RectWidth
Units=Windows
Snip=496.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y


[RectHeight]
DescEx="<p>Returns the height of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that height = bottom - top.</p>"
Units=Windows
SeeAlso=RectSize,RectWidth,NormalizeRect
Snip=127.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[RectSize]
DescEx="<p>Returns the size of the given rectangle.</p><p>The returned dimensions are always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top.</p>"
Units=Windows
Depends=RectWidth,RectHeight
SeeAlso=RectWidth,RectHeight,NormalizeRect
Snip=128.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[RectWidth]
DescEx="<p>Returns the width of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left.</p>"
Units=Windows
SeeAlso=RectSize,RectHeight,NormalizeRect
Snip=126.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[RepeatedDigits]
DescEx="<p>Checks if the given integer contains only a single repeated digit.</p>"
Extra="<p>An example of an integer with a single repeated digit is 5555.</p><p>Slightly modified from code contributed by Rubem Rocha.</p>"
Units=SysUtils,Math
SeeAlso=AllDigitsSame
Snip=497.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ReverseNumber]
DescEx="<p>Reverses the digits of integer <var>AValue</var> and returns the resulting value.</p><p><var>AValue</var> should be positive: zero is always returned for negative integers.</p>"
Extra="<p>Contributed by Rubem Nascimento da Rocha.</p>"
SeeAlso=ReverseNumberR
Snip=405.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[SignOfFloat]
DescEx="<p>Returns the sign of the given floating point value. Returns -1 if the value is positive, 0 if zero or +1 if negative.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=SignOfInt
Snip=205.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[SignOfInt]
DescEx="<p>Returns the sign of the given integer. Returns -1 if the integer is positive, 0 if zero or +1 if negative.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=SignOfFloat
Snip=206.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[SumOfLogs_Cardinal]
DisplayName=SumOfLogs (Cardinal overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Cardinal</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=643.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Double]
DisplayName=SumOfLogs (Double overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Double</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils,Math
Snip=647.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Extended]
DisplayName=SumOfLogs (Extended overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Extended</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils,Math
Snip=648.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Int64]
DisplayName=SumOfLogs (Int64 overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Int64</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=644.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Integer]
DisplayName=SumOfLogs (Integer overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Integer</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=645.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Single]
DisplayName=SumOfLogs (Single overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Single</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_UInt64
Units=SysUtils,Math
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=649.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_UInt64]
DisplayName=SumOfLogs (UInt64 overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>UInt64</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=646.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[DecimalToFraction]
DescEx="<p>Converts the given decimal to a fraction. The numerator and denominator are passed out as floating point numbers in <var>FractionNumerator</var> and <var>FractionDenominator</var> respectively.</p><p><var>AccuracyFactor</var> determines how accurate the conversion is to be.</p>"
Extra="<p>Examples of <var>AccuracyFactor</var> values: 0.0005 requires accuracy of 3 decimal places and 0.000005 requires accuracy of 5 decimal places.</p> <p>Adapted from the Turbo Pascal code by John Kennedy, Mathematics Department, Santa Monica College.</p>"
Units=SysUtils,Math
Snip=468.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[DigitSum]
DescEx="<p>Returns the sum of the digits from the given integer, using recursion.</p>"
Extra="<p>Sums of digits of negative numbers are negative, for example <mono>DigitSum(-42)=-6</mono>.</p><p>Contributed Rubem Nascimento da Rocha.</p>"
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
SeeAlso=DigitSumBase,DigitPowerSum
Snip=418.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[DistanceBetweenPoints_Float]
DisplayName="DistanceBetweenPoints (TPointF overload)"
DescEx="<p>Calculates the distance between two given points with double precision floating point valued coordinates.</p>"
Depends=TPointF
SeeAlso=DistanceBetweenPoints_Int
Units=Math
Snip=495.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[DistanceBetweenPoints_Int]
DisplayName="DistanceBetweenPoints (TPoint overload)"
DescEx="<p>Calculates the distance between two points with integer valued co-ordinates.</p>"
SeeAlso=DistanceBetweenPoints_Float
Units=Math,Types
Snip=494.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[GCD]
DescEx="<p>Determines the greatest common divisor of two given non-zero integers.</p>"
Extra="<p>Uses Euclid's method.</p><p>Note that <mono>GCD(a,b) = GCD(|a|,b) = GCD(a,|b|) = GCD(|a|,|b|)</mono>, which implies that <mono>GCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD2,LCD
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=201.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[GCD2]
DescEx="<p>Determines the greatest common divisor of two given non-zero integers.</p>"
Extra="<p>Uses a recursive implementation of Euclid's method.</p><p>Note that <mono>GCD2(a,b) = GCD2(|a|,b) = GCD2(a,|b|) = GCD2(|a|,|b|)</mono>, which implies that <mono>GCD2(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD,LCD
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=416.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[IsPrime]
DescEx="<p>Checks if the given number is prime.</p>"
Extra="<p>On versions of Delphi that support <var>Int64</var> parameters to the <var>Sqrt</var> function, the type of <var>N</var>, <var>Max</var> &amp; <var>Divisor</var> can be changed to <var>Int64</var>.</p> <p>Adapted from code contributed by Don Rowlett.</p>"
SeeAlso=IsPrime2
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=232.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[IsPrime2]
DescEx="<p>Checks if the given number is prime.</p>"
Extra="<p>Uses less code than <var>IsPrime</var> and does not require any floating point operations.</p><p>Contributed by daniel.</p>"
SeeAlso=IsPrime
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=570.dat
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[LCD]
DescEx="<p>Returns the least common divisor of two given non-zero integers.</p>"
Extra="<p>Note that <mono>LCD(a,b) = LCD(|a|,b) = LCD(a,|b|) = LCD(|a|,|b|)</mono>, which implies that <mono>LCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
Depends=GCD
SeeAlso=GCD,GCD2
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=467.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MaxOfArray_Double]
DisplayName="MaxOfArray (Double overload)"
DescEx="<p>Returns the maximum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=428.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MaxOfArray_Extended]
DisplayName="MaxOfArray (Extended overload)"
DescEx="<p>Returns the maximum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Extended,MaxOfArray_Double,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=429.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MaxOfArray_Int64]
DisplayName="MaxOfArray (Int64 overload)"
DescEx="<p>Returns the maximum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Int64,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Integer,MaxOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=430.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MaxOfArray_Integer]
DisplayName="MaxOfArray (Integer overload)"
DescEx="<p>Returns the maximum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Integer,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=431.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MaxOfArray_Single]
DisplayName="MaxOfArray (Single overload)"
DescEx="<p>Returns the maximum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Single,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=432.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Mid_Double]
DisplayName="Mid (Double overload)"
DescEx="<p>Returns the middle of three double precision floating point values.</p>"
Units=Math
SeeAlso=Mid_Extended,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Double,MinOfArray_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=423.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Mid_Extended]
DisplayName="Mid (Extended overload)"
DescEx="<p>Returns the middle of three extended precision floating point values.</p>"
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Extended,MinOfArray_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=424.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Mid_Int64]
DisplayName="Mid (Int64 overload)"
DescEx="<p>Returns the middle of three 64 bit integer values.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Integer,Mid_Single,MaxOfArray_Int64,MinOfArray_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=425.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Mid_Integer]
DisplayName="Mid (Integer overload)"
DescEx="<p>Returns the middle of three integer values.</p>"
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Single,MaxOfArray_Integer,MinOfArray_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=426.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Mid_Single]
DisplayName="Mid (Single overload)"
DescEx="<p>Returns the middle of three single precision floating point values.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Integer,MaxOfArray_Single,MinOfArray_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=427.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinMidMax_Double]
DisplayName="MinMidMax (Double overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three double precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Double,MaxOfArray_Double,MinOfArray_Double
Snip=472.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinMidMax_Extended]
DisplayName="MinMidMax (Extended overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three extended precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Extended,MaxOfArray_Extended,MinOfArray_Extended
Snip=473.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinMidMax_Int64]
DisplayName="MinMidMax (Int64 overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three 64 bit integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Integer,MinMidMax_Single,Mid_Int64,MaxOfArray_Int64,MinOfArray_Int64
Snip=474.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinMidMax_Integer]
DisplayName="MinMidMax (Integer overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Single,Mid_Integer,MaxOfArray_Integer,MinOfArray_Integer
Snip=475.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinMidMax_Single]
DisplayName="MinMidMax (Single overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three single precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,Mid_Single,MaxOfArray_Single,MinOfArray_Single
Snip=476.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinOfArray_Double]
DisplayName="MinOfArray (Double overload)"
DescEx="<p>Returns the minimum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=433.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinOfArray_Extended]
DisplayName="MinOfArray (Extended overload)"
DescEx="<p>Returns the minimum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Extended,MinOfArray_Double,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=434.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinOfArray_Int64]
DisplayName="MinOfArray (Int64 overload)"
DescEx="<p>Returns the minimum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Int64,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Integer,MinOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=435.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinOfArray_Integer]
DisplayName="MinOfArray (Integer overload)"
DescEx="<p>Returns the minimum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Integer,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=436.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[MinOfArray_Single]
DisplayName="MinOfArray (Single overload)"
DescEx="<p>Returns the minimum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Single,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=437.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[NormaliseFractionSign]
DescEx="<p>Normalises the sign of the fraction with numerator <var>Num</var> and denominator <var>Denom</var> so that <var>Num</var> takes the sign of the fraction and <var>Denom</var> is non-negative.</p>"
SeeAlso=FractionToStr,FractionToStrEx
Snip=559.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[Pow]
DescEx="<p>Raises integer value <var>Base</var> to non-negative integer power <var>Exponent</var> and returns the result.</p>"
SeeAlso=PowN,PowNZN,PowNZZ
Snip=561.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[PowN]
DescEx="<p>IEEE compliant function that raises real number <var>X</var> to the power <var>N</var>.</p>"
Extra="<p>See IEEE standard 754-2008 for Floating-Point Arithmetic, page 44.</p>"
Units=SysUtils,Math
SeeAlso=Pow,PowNZN,PowNZZ
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=633.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[PowNZN]
DescEx="<p>Raises integer <var>X</var> to non-negative integer power <var>N</var>.</p><p>If the result is too large to be represented as an <var>Int64</var> value then an <var>EOverflow</var> exception is raised.</p>"
Extra="<p>Returns an <var>integer</var> value because the power <var>N</var> is non-negative which guarantees that the result is integral.</p><p>Based on IEEE standard 754-2008 for Floating-Point Arithmetic, page 44, but which restricts <var>X</var> to an integer and <var>N</var> to a non-negative integer.</p>"
Units=SysUtils
SeeAlso=Pow,PowN,PowNZZ
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=634.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[PowNZZ]
DescEx="<p>Raises integer <var>X</var> to integer power <var>N</var>.</p>"
Extra="<p>Returns an <var>Extended</var> value since the result is not an integer when power <var>N</var> is negative.</p><p>Based on IEEE standard 754-2008 for Floating-Point Arithmetic, page 44, but which restricts <var>X</var> to an integer.</p>"
Units=SysUtils,
SeeAlso=Pow,PowN,PowNZN
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=635.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ResizeRect_A]
DisplayName="ResizeRect (TSize overload)"
DescEx="<p>Resizes rectangle <var>R</var> to size <var>NewSize</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
Depends=ResizeRect_B
SeeAlso=ResizeRect_B,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=420.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ResizeRect_B]
DisplayName="ResizeRect (Longint overload)"
DescEx="<p>Resizes rectangle <var>R</var> to the width and height given by <var>NewWidth</var> and <var>NewHeight</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
SeeAlso=ResizeRect_A,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=419.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ReverseNumberR]
DescEx="<p>Reverses the digits of the given integer, which must be non-negative, and returns the resulting value.</p><p>Uses recursion.</p>"
Extra="<p>Users of Delphi 7 and later can change the parameter and return type to <var>UInt64</var> and remove the assertion.</p><p>Slightly modified from code contributed by Rubem Nascimento da Rocha.</p>"
Units=Math
SeeAlso=ReverseNumber
Snip=406.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[SAR]
DescEx="<p>Performs an arithmetic right shift operation on the given value and returns the result. <var>Value</var> is shifted right by <var>Shift</var> bits.</p><p><var>Shift</var> must be in the range <mono>0..31</mono> and is adjusted if it is not.</p>"
Extra="<p><var>SAR</var> differs from the <strong>shr</strong> operator in that it preserves any sign bit.</p><p>For more information about the different kinds of right shift operator, see this <a href="http://delphidabbler.blogspot.co.uk/2013/02/the-two-faces-of-shr.html">blog post</a>.</p>"
Snip=560.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ScaleRect]
DescEx="<p>Scales the given rectangle by the given scale factor and returns the scaled rectangle.</p>"
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Types
SeeAlso=ZoomRatio_A,ZoomRatio_B,ZoomRatio_C,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=383.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[SimplifyFraction]
DescEx="<p>Simplifies the fraction with numerator <var>Num</var> and denominator <var>Denom</var> to its lowest terms.</p><p>If the fraction is already in its lowest terms then <var>Num</var> and <var>Denom</var> are left unchanged.</p>"
Depends=GCD
SeeAlso=DecimalToFraction,NormaliseFractionSign
Snip=621.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[StretchRect_A]
DisplayName="StretchRect (asymmetric overload)"
DescEx="<p>Stretches rectangle <var>R</var> by the given scaling factors and returns the result.</p><p>The rectangle's width is scaled by <var>ScalingX</var> and its height by <var>ScalingY</var>.</p><p>The top left corner of the rectangle is not changed.</p>"
Units=SysUtils,Types
SeeAlso=StretchRect_B,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=421.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[StretchRect_B]
DisplayName="StretchRect (symmetric overload)"
DescEx="<p>Stretches the rectangle <var>R</var> by scale factor <var>Scaling</var> and returns the result. Both width and height are stretched by the same scale factor.</p><p>The top left corner is not changed.</p>"
Units=Types
Depends=StretchRect_A
SeeAlso=StretchRect_A,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=422.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ZoomRatio_A]
DisplayName="ZoomRatio (Integer overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to a rectangle of width <var>SrcWidth</var> and height <var>SrcHeight</var> to fit it, without changing the aspect ratio, within a second rectangle of width <var>DestWidth</var> and height <var>DestHeight</var>.</p>"
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Math
SeeAlso=ZoomRatio_B,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=376.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ZoomRatio_B]
DisplayName="ZoomRatio (TSize overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to a rectangle of size <var>SrcSize</var> to fit it, without changing the aspect ratio, within a second rectangle of size <var>DestSize</var>.</p>"
Units=Types
Depends=ZoomRatio_A
SeeAlso=ZoomRatio_A,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=377.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ZoomRatio_C]
DisplayName="ZoomRatio (TRect overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to rectangle <var>SrcRect</var> to fit it, without changing the aspect ratio, within rectangle <var>DestRect</var>.</p>"
Units=Types
Depends=RectSize,ZoomRatio_B
SeeAlso=ZoomRatio_A,ZoomRatio_B,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=378.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
Delphi12A=Y
FPC=Y

[ArithmeticMean_Double]
DisplayName="ArithmeticMean (Double overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Double</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithmeticMean_Integer,ArithmeticMean_Cardinal,WeightedArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Double,LogarithmicMean,Median_Double,Mode,ModeAlt
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=650.dat
DelphiXE=Y
Delphi12A=Y

[ArithmeticMean_Integer]
DisplayName="ArithmeticMean (Integer overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Integer</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithmeticMean_Double,ArithmeticMean_Cardinal,WeightedArithmeticMean_Integer,GeometricMean_Integer,HarmonicMean_Integer,PowerMean_Integer,Median_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=651.dat
DelphiXE=Y
Delphi12A=Y

[ArithmeticMean_Cardinal]
DisplayName="ArithmeticMean (Cardinal overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Cardinal</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithmeticMean_Double,ArithmeticMean_Integer,WeightedArithmeticMean_Cardinal,GeometricMean_Cardinal,HarmonicMean_Cardinal,PowerMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=652.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithmeticMean_Double]
DisplayName="WeightedArithmeticMean (Double overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Double</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=SysUtils,Math
SeeAlso=ArithmeticMean_Double,WeightedArithmeticMean_Integer,WeightedArithmeticMean_Cardinal,WeightedGeometricMean_Double,WeightedHarmonicMean_Double,WeightedPowerMean_Double,LogarithmicMean
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=653.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithmeticMean_Integer]
DisplayName="WeightedArithmeticMean (Integer overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Integer</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=
Depends=WeightedArithmeticMean_Double
SeeAlso=ArithmeticMean_Integer,WeightedArithmeticMean_Double,WeightedArithmeticMean_Cardinal,WeightedGeometricMean_Integer,WeightedHarmonicMean_Integer,WeightedPowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=654.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithmeticMean_Cardinal]
DisplayName="WeightedArithmeticMean (Cardinal overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Cardinal</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=
Depends=WeightedArithmeticMean_Double
SeeAlso=ArithmeticMean_Cardinal,WeightedArithmeticMean_Double,WeightedArithmeticMean_Integer,WeightedGeometricMean_Cardinal,WeightedHarmonicMean_Cardinal,WeightedPowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=655.dat
DelphiXE=Y
Delphi12A=Y

[DigitSumBase]
DisplayName="DigitSumBase"
DescEx="<p>Calculates the sum of all the digits of integer <var>N</var> when epxressed in base <var>Base</var>. The returned value has the same sign as <var>N</var>.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt; 2 then an <var>EArgumentException</var> exception is raised.</p>"
Kind=routine
Units=SysUtils,Math
SeeAlso=DigitSum,DigitPowerSum
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=657.dat
DelphiXE=Y
Delphi12A=Y

[DigitCountBase]
DisplayName="DigitCountBase"
DescEx="<p>Returns the number of digits in integer <var>N</var> when expressed in base <var>Base</var>.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt; 2 then an <var>EArgumentException</var> exception is raised.</p>"
Extra="<p>The number of digits of an integer <em>n</em> &gt; 0 in base <em>b</em> &gt;= 2 can be expressed mathematically as:</p><p><mono>floor(log<em>b</em>(<em>n</em>)) + 1</mono></p><p>Unfortunately testing a Pascal implementation of this formula failed on some tests, e.g. <mono>DigitCount($FFFFFFFF,16)</mono>. This was probably due to floating point rounding errors. Therefore this implementation using only integer operations was used instead.</p>"
Kind=routine
Units=SysUtils
SeeAlso=DigitCount,DigitCount2,DigitCountR
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=658.dat
DelphiXE=Y
Delphi12A=Y

[DigitsOf]
DisplayName=DigitsOf
DescEx="<p>Returns an array containing the digits of integer <var>N</var> when expressed in base <var>Base</var>. The array is ordered with the least significant digit first.</p><p>The returned array contains the <em>decimal value</em> of the digit, for e.g. the hex symbol <em>F</em> is represented by an array element containing the value <em>15</em>.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt; 2 then an <var>EArgumentException</var> exception is raised.</p>"
Extra="<p>Examples:</p><p>1. <mono>DigitsOf($FACE,16)</mono> returns <mono>[15,10,12,14]</mono></p><p>2. <mono>DigitsOf(12,8)</mono> returns <mono>[1,4]</mono></p><p>3. <mono>DigitsOf(6,2)</mono> returns <mono>[1,1,0]</mono></p><p>4. <mono>DigitsOf(6,10)</mono> returns <mono>[6]</mono></p><p>5. <mono>DigitsOf(0,8)</mono> returns <mono>[0]</mono></p>"
Kind=routine
Units=SysUtils
Depends=DigitCountBase
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=659.dat
DelphiXE=Y
Delphi12A=Y

[DigitPowerSum]
DisplayName=DigitPowerSum
DescEx="<p>Calculates the sum of all the digits of integer <var>N</var> in base <var>Base</var> where each digit is raised to the power <var>Exponent</var>. The returned value has the same sign as <var>N</var>.</p><p>If the result is too large to be represented as an <var>Int64</var> value then an <var>EOverflow</var> exception is raised.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt;= 2 then an <var>EArgumentException</var> exception is raised.</p>"
Kind=routine
Units=SysUtils,Math
Depends=PowNZN
SeeAlso=DigitSum,DigitSumBase
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=661.dat
DelphiXE=Y
Delphi12A=Y

[IsPalindromic]
DisplayName="IsPalindromic"
DescEx="<p>Checks if the absolute value of integer <var>N</var> is palindromic in base <var>Base</var>.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt; 2 then an <var>EArgumentException</var> exception is raised.</p>"
Extra="<p>A number expressed in a specified base is palindromic if it remains unchanged when its digits are reversed. See <a href="https://en.m.wikipedia.org/wiki/Palindromic_number">Wikipedia</a> for a formal definition and examples.</p><p>Strictly speaking a palindromic number should be non-negative. However, <var>IsPalindromic</var> considers negative numbers to be palindromic if and only if their absolute value is palindromic.</p>"
Kind=routine
Units=SysUtils
Depends=DigitsOf
SeeAlso=IsNarcissistic
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=660.dat
DelphiXE=Y
Delphi12A=Y

[IsNarcissistic]
DisplayName=IsNarcissistic
DescEx="<p>Checks if the absolute value of integer <var>N</var> is a narcissistic number in base <var>Base</var>.</p><p>Bases up to 255 are supported. If <var>Base</var> &lt;= 2 then an <var>EArgumentException</var> exception is raised. An <var>EOverflow</var> exception may be raised for large numbers and bases.</p>"
Extra="<p>A narcissistic number in a given number base is a number that is the sum of its own digits each raised to the power of the number of digits. See <a href="https://en.wikipedia.org/wiki/Narcissistic_number">Wikipedia</a> for a formal definition and examples.</p><p>Strictly speaking a palindromic number should be non-negative. However, <var>IsNarcissistic</var> considers negative numbers to be narcissistic if and only if their absolute value is narcissistic.</p>"
Kind=routine
Depends=DigitCountBase,DigitPowerSum
SeeAlso=IsPalindromic
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=662.dat
DelphiXE=Y
Delphi12A=Y

[LSE]
DisplayName=LSE
DescEx="<p>Returns the logarithm of the sum of the exponentials of the given array of floating pointing point numbers.</p><p>An <var>EArgumentException</var> exception is raised if the array is empty.</p>"
Extra="<p>The mathematical definition of <em>LSE</em> is <em>LSE(x1,...,xn) = log(exp(x1) + ... + exp(xn))</em>. The version of the algorithm used here uses an <a href="https://gregorygundersen.com/blog/2020/02/09/log-sum-exp/">algebraic trick</a> to minimise the risk of overflow.</p><p>For more information see <a href="https://nhigham.com/2021/01/05/what-is-the-log-sum-exp-function/">What Is the Log-Sum-Exp Function?</a> by Nick Higham.</p>"
Kind=routine
Units=SysUtils
Depends=MaxOfArray_Double
SeeAlso=Softmax
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=663.dat
DelphiXE=Y
Delphi12A=Y

[Softmax]
DisplayName=Softmax
DescEx="<p>Applies the <a href="https://en.wikipedia.org/wiki/Softmax_function"><em>softmax</em></a> function to each element of floating point array <var>A</var> and normalizes them into a probability distribution proportional to the exponentials of the elements of <var>A</var>. The normalised values are returned as an array of the same size as <var>A</var>.</p><p>An <var>EArgumentException</var> exception is raised if <var>A</var> is empty.</p>"
Extra="<p>The <em>softmax</em> function is often used in statistics and in machine learning. It is closely related to the <em>log-sum-exp</em> (aka <em>LSE</em>) function since, for vector <strong>x</strong>=(x1,...,xn), <em>softmax(<strong>x</strong>)=exp[<strong>x</strong>&#8722;LSE(<strong>x</strong>)]</em>.</p>"
Kind=routine
Units=SysUtils
Depends=LSE
SeeAlso=LSE,MaxOfArray_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=664.dat
DelphiXE=Y
Delphi12A=Y

[Median_Double]
DisplayName="Median (Double overload)"
DescEx="<p>Returns the median of an array of floating point values.</p><p>Raises an <var>EArgumentException</var> exception if the array is empty.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
SeeAlso=Median_Integer,ArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Double,LogarithmicMean,ModeAlt,Mode
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=665.dat
DelphiXE=Y
Delphi12A=Y

[Median_Integer]
DisplayName="Median (Integer overload)"
DescEx="<p>Returns the median of an array of integer values.</p><p>Raises an <var>EArgumentException</var> exception if the array is empty.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
SeeAlso=Median_Double,ArithmeticMean_Integer,GeometricMean_Integer,HarmonicMean_Integer,PowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=666.dat
DelphiXE=Y
Delphi12A=Y

[MinMaxOfArray_Double]
DisplayName="MinMaxOfArray (Double overload)"
DescEx="<p>Finds the minimum and maximum values contained in the non-empty array, <var>A</var>, of double precision floating point values. <var>MinValue</var> and <var>MaxValue</var> are set to the minimum and maximum values, respectively.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Kind=routine
Units=SysUtils
SeeAlso=MinMaxOfArray_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=669.dat
DelphiXE=Y
Delphi12A=Y

[MinMaxOfArray_Integer]
DisplayName="MinMaxOfArray (Integer overload)"
DescEx="<p>Finds the minimum and maximum values contained in the non-empty <var>Integer</var> array <var>A</var>. <var>MinValue</var> and <var>MaxValue</var> are set to the minimum and maximum values, respectively.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Kind=routine
Units=SysUtils
SeeAlso=MinMaxOfArray_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=670.dat
DelphiXE=Y
Delphi12A=Y

[RescaleRange_Double]
DisplayName="RescaleRange (Double overload)"
DescEx="<p>Rescales the elements of array <var>A</var> containing a range of <var>Double</var> values so that each value of <var>A</var> is mapped to a value in the range [0..1].</p><p>An array of the same size as <var>A</var> is returned where each element contains the rescaled value of the corresponding element of <var>A</var>.</p><p><var>A</var> must not be empty and not all elements may be the same value. <var>EArgumentException</var> is raised if either condition is not met.</p>"
Kind=routine
Units=SysUtils,Types,Math
Depends=MinMaxOfArray_Double
SeeAlso=NormaliseByWeight_Double,RescaleRange_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=667.dat
DelphiXE=Y
Delphi12A=Y

[RescaleRange_Integer]
DisplayName="RescaleRange (Integer overload)"
DescEx="<p>Rescales the elements of array <var>A</var> containing a range of <var>Integer</var> values so that each value of <var>A</var> is mapped to a value in the range [0..1].</p><p>An array of the same size as <var>A</var> is returned where each element contains the rescaled value of the corresponding element of <var>A</var>.</p><p><var>A</var> must not be empty and not all elements may be the same value. <var>EArgumentException</var> is raised if either condition is not met.</p>"
Kind=routine
Units=SysUtils,Types
Depends=MinMaxOfArray_Integer
SeeAlso=NormaliseByWeight_Cardinal,RescaleRange_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=674.dat
DelphiXE=Y
Delphi12A=Y

[NormaliseByWeight_Double]
DisplayName="NormaliseByWeight (Double overload)"
DescEx="<p>Normalises the values in floating point array <var>A</var> so that each value of <var>A</var> is mapped to a value in the range [0..1], where the total of all the values is 1. The relative weights of the values are preserved.</p><p>An array of the same size as <var>A</var> is returned where each element contains the normalised value of the corresponding element of <var>A</var>.</p><p><var>A</var> must not be empty. All elements of <var>A</var> must be &gt;= 0, with at least one element &gt; 0. <var>EArgumentException</var> is raised if these conditions are not met.</p>"
Kind=routine
Units=SysUtils,Types,Math
SeeAlso=RescaleRange_Double,NormaliseByWeight_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=668.dat
DelphiXE=Y
Delphi12A=Y

[NormaliseByWeight_Cardinal]
DisplayName="NormaliseByWeight (Cardinal overload)"
DescEx="<p>Normalises the values in unsigned integer array <var>A</var> so that each value of <var>A</var> is mapped to a value in the range [0..1], where the total of all the values is 1. The relative weights of the values are preserved.</p><p>An array of the same size as <var>A</var> is returned where each element contains the normalised value of the corresponding element of <var>A</var>.</p><p><var>A</var> must not be empty and must have at least one non-zero element. <var>EArgumentException</var> is raised if these conditions are not met.</p>"
Kind=routine
Units=SysUtils,Types
SeeAlso=RescaleRange_Integer,NormaliseByWeight_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=671.dat
DelphiXE=Y
Delphi12A=Y

[RangeOf_Double]
DisplayName="RangeOf (Double overload)"
DescEx="<p>Returns the length of the range of values in non-empty <var>Double</var> array <var>A</var>.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Kind=routine
Units=Math
Depends=MinMaxOfArray_Double
SeeAlso=RangeOf_Integer,RescaleRange_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=672.dat
DelphiXE=Y
Delphi12A=Y

[RangeOf_Integer]
DisplayName="RangeOf (Integer overload)"
DescEx="<p>Returns the length of the range of values in non-empty <var>Integer</var> array <var>A</var>.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Kind=routine
Depends=MinMaxOfArray_Integer
SeeAlso=RangeOf_Double,RescaleRange_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=673.dat
DelphiXE=Y
Delphi12A=Y

[GeometricMean_Double]
DisplayName="GeometricMean (Double overload)"
DescEx="<p>Returns the geometric mean of an array of positive <var>Double</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty while <var>EArgumentOutOfRangeException</var> is raised if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Geometric_mean">Wikipedia</a> for information about the geometric mean.</p>"
Kind=routine
Units=SysUtils
Depends=SumOfLogs_Double
SeeAlso=ArithmeticMean_Double,GeometricMean_Integer,GeometricMean_Cardinal,WeightedGeometricMean_Double,HarmonicMean_Double,PowerMean_Double,Median_Double,Mode,ModeAlt,LogarithmicMean
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=675.dat
DelphiXE=Y
Delphi12A=Y

[GeometricMean_Cardinal]
DisplayName="GeometricMean (Cardinal overload)"
DescEx="<p>Returns the geometric mean of an array of positive <var>Cardinal</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty while <var>EArgumentOutOfRangeException</var> is raised if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Geometric_mean">Wikipedia</a> for information about the geometric mean.</p>"
Kind=routine
Units=SysUtils
Depends=SumOfLogs_Cardinal
SeeAlso=ArithmeticMean_Cardinal,GeometricMean_Integer,GeometricMean_Double,WeightedGeometricMean_Cardinal,HarmonicMean_Cardinal,PowerMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=676.dat
DelphiXE=Y
Delphi12A=Y

[GeometricMean_Integer]
DisplayName="GeometricMean (Integer overload)"
DescEx="<p>Returns the geometric mean of an array of positive <var>Integer</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty while <var>EArgumentOutOfRangeException</var> is raised if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Geometric_mean">Wikipedia</a> for information about the geometric mean.</p>"
Kind=routine
Units=SysUtils
Depends=SumOfLogs_Integer
SeeAlso=ArithmeticMean_Integer,GeometricMean_Cardinal,GeometricMean_Double,WeightedGeometricMean_Integer,HarmonicMean_Integer,PowerMean_Integer,Median_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=677.dat
DelphiXE=Y
Delphi12A=Y

[WeightedGeometricMean_Double]
DisplayName="WeightedGeometricMean (Double overload)"
DescEx="<p>Calculates and returns the weighted geometric mean of the array <var>Values</var> of positive <var>Double</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Weighted_geometric_mean">Wikipedia</a> for information about the weighted geometric mean.</p>"
Units=SysUtils,Types
Depends=NormaliseByWeight_Double
SeeAlso=GeometricMean_Double,WeightedArithmeticMean_Double,WeightedGeometricMean_Cardinal,WeightedGeometricMean_Integer,WeightedHarmonicMean_Double,WeightedPowerMean_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=678.dat
DelphiXE=Y
Delphi12A=Y

[WeightedGeometricMean_Cardinal]
DisplayName="WeightedGeometricMean (Cardinal overload)"
DescEx="<p>Calculates and returns the weighted geometric mean of the array <var>Values</var> of positive <var>Cardinal</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Weighted_geometric_mean">Wikipedia</a> for information about the weighted geometric mean.</p>"
Units=Types
Depends=WeightedGeometricMean_Double
SeeAlso=GeometricMean_Cardinal,WeightedArithmeticMean_Cardinal,WeightedGeometricMean_Double,WeightedGeometricMean_Integer,WeightedPowerMean_Cardinal, WeightedHarmonicMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=679.dat
DelphiXE=Y
Delphi12A=Y

[WeightedGeometricMean_Integer]
DisplayName="WeightedGeometricMean (Integer overload)"
DescEx="<p>Calculates and returns the weighted geometric mean of the array <var>Values</var> of positive <var>Integer</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Weighted_geometric_mean">Wikipedia</a> for information about the weighted geometric mean.</p>"
Units=Types
Depends=WeightedGeometricMean_Double
SeeAlso=GeometricMean_Integer,WeightedArithmeticMean_Integer,WeightedGeometricMean_Double,WeightedGeometricMean_Cardinal,WeightedHarmonicMean_Integer,WeightedPowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=680.dat
DelphiXE=Y
Delphi12A=Y

[SumOfReciprocals_Double]
DisplayName="SumOfReciprocals (Double overload)"
DescEx="<p>Calculates the sum of the reciprocal values of all elements of <var>Double</var> array <var>A</var>.</p><p><var>A</var> must not be empty and all its elements must be positive. <var>EArgumentException</var> is raised if either of these conditions is not satisfied.</p>"
Units=SysUtils,Math
SeeAlso=SumOfReciprocals_Integer,SumOfReciprocals_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=681.dat
DelphiXE=Y
Delphi12A=Y

[SumOfReciprocals_Integer]
DisplayName="SumOfReciprocals (Integer overload)"
DescEx="<p>Calculates the sum of the reciprocal values of all elements of <var>Integer</var> array <var>A</var>.</p><p><var>A</var> must not be empty and all its elements must be positive. <var>EArgumentException</var> is raised if either of these conditions is not satisfied.</p>"
Units=SysUtils
SeeAlso=SumOfReciprocals_Integer,SumOfReciprocals_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=682.dat
DelphiXE=Y
Delphi12A=Y

[SumOfReciprocals_Cardinal]
DisplayName="SumOfReciprocals (Cardinal overload)"
DescEx="<p>Calculates the sum of the reciprocal values of all elements of <var>Cardinal</var> array <var>A</var>.</p><p><var>A</var> must not be empty and all its elements must be positive. <var>EArgumentException</var> is raised if either of these conditions is not satisfied.</p>"
Units=SysUtils
SeeAlso=SumOfReciprocals_Double,SumOfReciprocals_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=683.dat
DelphiXE=Y
Delphi12A=Y

[HarmonicMean_Double]
DisplayName="HarmonicMean (Double overload)"
DescEx="<p>Returns the harmonic mean of an array of positive <var>Double</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty or if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Harmonic_mean">Wikipedia</a> for information about the harmonic mean.</p>"
Depends=SumOfReciprocals_Double
SeeAlso=HarmonicMean_Integer,HarmonicMean_Cardinal,ArithmeticMean_Double,GeometricMean_Double,PowerMean_Double,Mode,ModeAlt,Median_Double,LogarithmicMean,WeightedHarmonicMean_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=684.dat
DelphiXE=Y
Delphi12A=Y

[HarmonicMean_Cardinal]
DisplayName="HarmonicMean (Cardinal overload)"
DescEx="<p>Returns the harmonic mean of an array of positive <var>Cardinal</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty or if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Harmonic_mean">Wikipedia</a> for information about the harmonic mean.</p>"
Depends=SumOfReciprocals_Cardinal
SeeAlso=HarmonicMean_Double,HarmonicMean_Integer,ArithmeticMean_Cardinal,GeometricMean_Cardinal,PowerMean_Cardinal,WeightedHarmonicMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=685.dat
DelphiXE=Y
Delphi12A=Y

[HarmonicMean_Integer]
DisplayName="HarmonicMean (Integer overload)"
DescEx="<p>Returns the harmonic mean of an array of positive <var>Integer</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty or if any array element is not positive.</p>"
Extra="<p>See <a href="https://en.m.wikipedia.org/wiki/Harmonic_mean">Wikipedia</a> for information about the harmonic mean.</p>"
Depends=SumOfReciprocals_Integer
SeeAlso=HarmonicMean_Cardinal,HarmonicMean_Double,ArithmeticMean_Integer,GeometricMean_Integer,PowerMean_Integer,WeightedHarmonicMean_Integer,Median_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=686.dat
DelphiXE=Y
Delphi12A=Y

[WeightedHarmonicMean_Double]
DisplayName="WeightedHarmonicMean (Double overload)"
DescEx="<p>Calculates and returns the weighted harmonic mean of the array <var>Values</var> of positive <var>Double</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean">Wikipedia</a> for information about the weighted harmonic mean.</p>"
Kind=routine
Units=SysUtils,Types
Depends=NormaliseByWeight_Double
SeeAlso=HarmonicMean_Double,WeightedHarmonicMean_Cardinal,WeightedHarmonicMean_Integer,WeightedArithmeticMean_Double,WeightedGeometricMean_Double,WeightedPowerMean_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=687.dat
DelphiXE=Y
Delphi12A=Y

[WeightedHarmonicMean_Cardinal]
DisplayName="WeightedHarmonicMean (Cardinal overload)"
DescEx="<p>Calculates and returns the weighted harmonic mean of the array <var>Values</var> of positive <var>Cardinal</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean">Wikipedia</a> for information about the weighted harmonic mean.</p>"
Kind=routine
Units=Types
Depends=WeightedHarmonicMean_Double
SeeAlso=HarmonicMean_Cardinal,WeightedHarmonicMean_Double,WeightedHarmonicMean_Integer,WeightedArithmeticMean_Cardinal,WeightedGeometricMean_Cardinal,WeightedPowerMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=688.dat
DelphiXE=Y
Delphi12A=Y

[WeightedHarmonicMean_Integer]
DisplayName="WeightedHarmonicMean (Integer overload)"
DescEx="<p>Calculates and returns the weighted harmonic mean of the array <var>Values</var> of positive <var>Integer</var> values where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; all elements of <var>Values</var> must be positive; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Extra="<p>See <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean">Wikipedia</a> for information about the weighted harmonic mean.</p>"
Kind=routine
Units=Types
Depends=WeightedHarmonicMean_Double
SeeAlso=HarmonicMean_Integer,WeightedHarmonicMean_Double,WeightedHarmonicMean_Cardinal,WeightedArithmeticMean_Integer,WeightedGeometricMean_Integer,WeightedPowerMean_Integer,Median_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=689.dat
DelphiXE=Y
Delphi12A=Y

[LogarithmicMean]
DisplayName="LogarithmicMean"
DescEx="<p>Returns the logarithmic mean of two positive floating point values, <var>X</var> and <var>Y</var>.</p><p>Raises <var>EArgumentException</var> if either <var>X</var> or <var>Y</var> is not positive.</p>"
Extra="<p>See <a href="https://www.ryantoomey.org/wiki/Logarithmic_mean_average">Chemepedia</a> for information about the logarithmic mean.</p>"
Kind=routine
Units=SysUtils,Math
SeeAlso=ArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Double,Median_Double,Mode,ModeAlt
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=690.dat
DelphiXE=Y
Delphi12A=Y

[PowerMean_Double]
DisplayName="PowerMean (Double overload)"
DescEx="<p>Returns the power mean of the elements of <var>Double</var> array <var>Values</var>, with exponent <var>Lambda</var>.</p><p>An <var>EArgumentException</var> is raised if the array is empty, if any array element is negative or if <var>Lambda</var> is zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://en.m.wikipedia.org/wiki/Generalized_mean">Wikipedia</a> for further information.</p>"
Kind=routine
Units=SysUtils,Math
SeeAlso=ArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Cardinal,PowerMean_Integer,LogarithmicMean,WeightedPowerMean_Double,Mode,ModeAlt,Median_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=691.dat
DelphiXE=Y
Delphi12A=Y

[PowerMean_Integer]
DisplayName="PowerMean (Integer overload)"
DescEx="<p>Returns the power mean of the elements of <var>Integer</var> array <var>Values</var>, with exponent <var>Lambda</var>.</p><p>An <var>EArgumentException</var> is raised if the array is empty, if any array element is negative or if <var>Lambda</var> is zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://en.m.wikipedia.org/wiki/Generalized_mean">Wikipedia</a> for further information.</p>"
Kind=routine
Units=Types
Depends=PowerMean_Double
SeeAlso=ArithmeticMean_Integer,GeometricMean_Integer,HarmonicMean_Integer,PowerMean_Double,PowerMean_Cardinal,LogarithmicMean,WeightedPowerMean_Integer,Median_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=692.dat
DelphiXE=Y
Delphi12A=Y

[PowerMean_Cardinal]
DisplayName="PowerMean (Cardinal overload)"
DescEx="<p>Returns the power mean of the elements of <var>Cardinal</var> array <var>Values</var>, with exponent <var>Lambda</var>.</p><p>An <var>EArgumentException</var> is raised if the array is empty or if <var>Lambda</var> is zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://en.m.wikipedia.org/wiki/Generalized_mean">Wikipedia</a> for further information.</p>"
Kind=routine
Units=Types
Depends=PowerMean_Double
SeeAlso=ArithmeticMean_Cardinal,GeometricMean_Cardinal,HarmonicMean_Cardinal,PowerMean_Double,PowerMean_Integer,LogarithmicMean,WeightedPowerMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=693.dat
DelphiXE=Y
Delphi12A=Y

[WeightedPowerMean_Double]
DisplayName="WeightedPowerMean (Double overload)"
DescEx="<p>Returns the weighted power mean of the elements of <var>Double</var> array <var>Values</var>, with exponent <var>Lambda</var>. Each term is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; no element of <var>Values</var> may be negative; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero; <var>Lambda</var> must not be zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://www.statisticshowto.com/power-mean-generalized-mean/">Statistics How To</a> for further information.</p>"
Kind=routine
Units=SysUtils,Types,Math
Depends=NormaliseByWeight_Double
SeeAlso=WeightedArithmeticMean_Double,WeightedGeometricMean_Double,WeightedHarmonicMean_Double,PowerMean_Double,WeightedPowerMean_Cardinal,WeightedPowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=694.dat
DelphiXE=Y
Delphi12A=Y

[WeightedPowerMean_Integer]
DisplayName="WeightedPowerMean (Integer overload)"
DescEx="<p>Returns the weighted power mean of the elements of <var>Integer</var> array <var>Values</var>, with exponent <var>Lambda</var>. Each term is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; no element of <var>Values</var> may be negative; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero; <var>Lambda</var> must not be zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://www.statisticshowto.com/power-mean-generalized-mean/">Statistics How To</a> for further information.</p>"
Kind=routine
Units=Types
Depends=WeightedPowerMean_Double
SeeAlso=WeightedArithmeticMean_Integer,WeightedGeometricMean_Integer,WeightedHarmonicMean_Integer,PowerMean_Integer,WeightedPowerMean_Cardinal,WeightedPowerMean_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=695.dat
DelphiXE=Y
Delphi12A=Y

[WeightedPowerMean_Cardinal]
DisplayName="WeightedPowerMean (Cardinal overload)"
DescEx="<p>Returns the weighted power mean of the elements of <var>Cardinal</var> array <var>Values</var>, with exponent <var>Lambda</var>. Each term is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero; <var>Lambda</var> must not be zero.</p>"
Extra="<p>The <em>power mean</em> is also known as the <em>generalised mean</em> and the <em>Holder mean</em>.</p><p>See <a href="https://www.statisticshowto.com/power-mean-generalized-mean/">Statistics How To</a> for further information.</p>"
Kind=routine
Units=Types
Depends=WeightedPowerMean_Double
SeeAlso=WeightedArithmeticMean_Cardinal,WeightedGeometricMean_Cardinal,WeightedHarmonicMean_Cardinal,PowerMean_Cardinal,WeightedPowerMean_Double,WeightedPowerMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=696.dat
DelphiXE=Y
Delphi12A=Y

[Mode]
DisplayName="Mode"
DescEx="<p>Calculates the mode of array <var>A</var> of integer data. Returns an array containing the mode or modes of the data.</p><p>If the data has a single mode, then a single element array containing the mode is returned. If the data is multi-modal then all the modes are returned. If all data items occur with equal frequency then an array of all unique data items is returned. The returned data is sorted in ascending order.</p><p>Raises <var>EArgumentException</var> if <var>A</var> has fewer than two elements.</p>"
Extra="<p>Some sources state that if all numbers in <var>A</var> occur the same number of times, and not all data items are the same, then no mode is defined. It is not obvious how this situation should be handled.</p><p>This function takes the same approach as the <a href="https://www.calculatorsoup.com/calculators/statistics/mean-median-mode.php">CalculatorSoup</a> online <em>Mean, Median, Mode</em> calculator. For example <mono>Mode([1,1,2,2,3,3])</mono> returns <mono>[1,2,3]</mono> while <mono>Mode([2,2,2])</mono> returns <mono>[2]</mono>.</p><p>Another solution is to return an empty array when there is no mode. This is the approach taken by <var>ModeAlt</var>.</p><p>See <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">Wikipedia</a> for more information about mode.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
Depends=CountOccurrences
SeeAlso=Median_Double,ArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Double,LogarithmicMean,ModeAlt,ModeCount,HasMode
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=697.dat
DelphiXE=Y
Delphi12A=Y

[ModeAlt]
DisplayName="ModeAlt"
DescEx="<p>Calculates the mode of array <var>A</var> of integer data. Returns an array containing the mode or modes of the data, if any.</p><p>If the data has a single mode, then a single element array containing the mode is returned. If the data is multi-modal then all the modes are returned, sorted in ascending order. If all data items occur with equal frequency, and not all data items are the same, then there is no mode and an empty array is returned.</p><p>Raises <var>EArgumentException</var> if <var>A</var> has fewer than two elements.</p>"
Extra="<p>Some sources state that if all numbers in <var>A</var> occur the same number of times, and not all data items are the same, then no mode is defined. It is not obvious how this situation should be handled.</p><p>This function returns an empty array when there is no mode. For example <mono>ModeAlt([1,1,2,2,3,3])</mono> returns an empty array while <mono>ModeAlt([2,2,2])</mono> returns <mono>[2]</mono>.</p><p>Another solution, adopted by <a href="https://www.calculatorsoup.com/calculators/statistics/mean-median-mode.php">CalculatorSoup</a> is to return all the unique elements of <var>A</var>. The <var>Mode</var> function also takes this approach.</p><p>See <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">Wikipedia</a> for more information about mode.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
Depends=CountOccurrences
SeeAlso=Median_Double,ArithmeticMean_Double,GeometricMean_Double,HarmonicMean_Double,PowerMean_Double,LogarithmicMean,Mode,ModeCount,HasNode
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=698.dat
DelphiXE=Y
Delphi12A=Y

[CountOccurrences]
DisplayName="CountOccurrences"
DescEx="<p>Calculates the number of occurrences of each unique element of array <var>A</var>. An array of <var>TPair&lt;Integer,Cardinal&gt;</var> values is returned, where the <var>Key</var> field of each <var>TPair</var> element is the integer and the <var>Value</var> field is the number of times the integer occurs in <var>A</var>. The returned array is sorted on the <var>Key</var> field.</p><p>Raises <var>EArgumentException</var> if <var>A</var> is empty.</p>"
Extra="<p>Examples of use and output:</p><p><mono>CountOccurrences([2,2,2])</mono> returns <mono>[(Key:2;Value:3)]</mono>.</p><p><mono>CountOccurrences([56,42,42,42,56,-66])</mono> returns <mono>[(Key:-66;Value:1),(Key:42;Value:3),(Key:56;Value:2)]</mono>. Note how the returned array is sorted.</p><p><mono>CountOccurrences([12])</mono> returns <mono>[Key:12;Value:2]</mono>.</p>"
Kind=routine
Units=SysUtils,Generics.Defaults,Generics.Collections
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=699.dat
DelphiXE=Y
Delphi12A=Y

[ModeCount]
DisplayName="ModeCount"
DescEx="<p>Returns the number of modes of integer array <var>A</var>.</p><p>Raises <var>EArgumentException</var> if <var>A</var> has fewer than two elements.</p>"
Extra="<p>A return value of zero indicates that the value of the array have no mode. This is considered to be when every integer occurs the same number of times and not all data items are the same.</p><p><strong>Examples:</strong></p><p><mono>ModeCount([1,1,2,2,3,3])</mono> returns 0 because 1, 2 and 3 all occur the same number of times. The mode is undefined.</p><p><mono>ModeCount([2,2,2])</mono> returns 1 because all the integers are the same (the mode is 2).</p><p><mono>ModeCount([1,2,3,3,4,5])</mono> returns 1 (the mode is 3).</p><p><mono>ModeCount([1,2,2,3,3])</mono> returns 2 (the modes are 2 &amp; 3).</p><p>See <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">Wikipedia</a> for more information about mode.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
Depends=CountOccurrences
SeeAlso=Mode,ModeAlt,HasMode
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=700.dat
DelphiXE=Y
Delphi12A=Y

[HasMode]
DisplayName="HasMode"
DescEx="<p>Checks if the given array of integers <var>A</var> has a mode and returns True if so.</p><p>Raises <var>EArgumentException</var> if <var>A</var> has fewer than two elements.</p>"
Extra="<p>An array of integers is considered to have a mode unless every integer occurs the same number of times and not all data items are the same.</p><p><strong>Examples:</strong></p><p><mono>HasNode([1,1,2,2,3,3])</mono> returns False because 1, 2 and 3 all occur the same number of times.</p><p><mono>HasNode([2,2,2])</mono> returns True because all the integers are the same (the mode is 2).</p><p><mono>HasNode([1,2,3,3,4,5])</mono> returns True (the mode is 3).</p><p><mono>HasNode([1,2,2,3,3])</mono> returns True (the modes are 2 &amp; 3).</p><p>See <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">Wikipedia</a> for more information about mode.</p>"
Kind=routine
Units=SysUtils,Generics.Collections
Depends=CountOccurrences
SeeAlso=Mode,ModeAlt,ModeCount
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=701.dat
DelphiXE=Y
Delphi12A=Y

[RMS_Double]
DisplayName="RMS (Double overload)"
DescEx="<p>Calculates the root mean square of the elements of <var>Double</var> floating point array <var>A</var>.</p><p>Raises <var>EArgumentException</var> if <var>A</var> is empty.</p>"
Kind=routine
Units=SysUtils,Math
Depends=ArithmeticMean_Double
SeeAlso=RMS_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=702.dat
DelphiXE=Y
Delphi12A=Y

[RMS_Integer]
DisplayName="RMS (Integer overload)"
DescEx="<p>Calculates the root mean square of the elements of <var>Integer</var> array <var>A</var>.</p><p>Raises <var>EArgumentException</var> if <var>A</var> is empty.</p>"
Kind=routine
Units=SysUtils,Math
Depends=ArithmeticMean_Double
SeeAlso=RMS_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=703.dat
DelphiXE=Y
Delphi12A=Y

[TSS_Double]
DisplayName="TSS (Double overload)"
DescEx="<p>Calculates the statistical total sum of squares of the elements of <var>Double</var> array <var>A</var>.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Extra="<p>See <a href="https://en.wikipedia.org/wiki/Total_sum_of_squares">Wikipedia</a> for an explanation of the <var>TSS</var> function.</p><p><strong>Note:</strong> <var>TSS</var> is not the same as the <var>SumOfSquares</var> function in the Delphi RTL.</p>"
Kind=routine
Depends=ArithmeticMean_Double
SeeAlso=TSS_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=704.dat
DelphiXE=Y
Delphi12A=Y

[TSS_Integer]
DisplayName="TSS (Integer overload)"
DescEx="<p>Calculates the statistical total sum of squares of the elements of <var>Integer</var> array <var>A</var>.</p><p><var>EArgumentException</var> is raised if <var>A</var> is empty.</p>"
Extra="<p>See <a href="https://en.wikipedia.org/wiki/Total_sum_of_squares">Wikipedia</a> for an explanation of the <var>TSS</var> function.</p><p><strong>Note:</strong> <var>TSS</var> is not the same as the <var>SumOfSquares</var> function in the Delphi RTL.</p>"
Kind=routine
Depends=ArithmeticMean_Integer
SeeAlso=TSS_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=705.dat
DelphiXE=Y
Delphi12A=Y
