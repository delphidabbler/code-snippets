# DelphiDabbler Code Snippets Database v2
#
# Mathematics category file
#
# This file is licensed under the MIT license, copyright © 2024 Peter Johnson,
# https://gravatar.com/delphidabbler

[AllDigitsDifferent]
DescEx="<p>Checks if all the digits of the given integer are different to each other.</p>"
Extra="<p>An example of an integer with all digits different is 15862.</p>"
SeeAlso=AllDigitsSame
Snip=498.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AllDigitsSame]
DescEx="<p>Checks if all the digits of the given integer are the same.</p>"
Extra="<p>An example of an integer with all digits the same is 777777.</p>"
SeeAlso=AllDigitsDifferent,RepeatedDigits
Snip=499.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ArraySum_Cardinal]
DisplayName="ArraySum (Cardinal overload)"
DescEx="<p>Returns the sum of all <var>Cardinal</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=636.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Double]
DisplayName="ArraySum (Double overload)"
DescEx="<p>Returns the sum of all <var>Double</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=637.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Extended]
DisplayName="ArraySum (Extended overload)"
DescEx="<p>Returns the sum of all <var>Extended</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Int64,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=638.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Int64]
DisplayName="ArraySum (Int64 overload)"
DescEx="<p>Returns the sum of all <var>Int64</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Integer,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=639.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Integer]
DisplayName="ArraySum (Integer overload)"
DescEx="<p>Returns the sum of all <var>Integer</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Single,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=640.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_Single]
DisplayName="ArraySum (Single overload)"
DescEx="<p>Returns the sum of all <var>Single</var> floating point elements of array <var>A</var>.</p><p><mono>0.0</mono> is returned if the array is empty.</p>"
Extra="<p>This routine duplicates the functionality of Delphi&apos;s <var>Math.SUM</var> routine, but circumvents the access violation caused by <var>Math.SUM</var> in some circumstances.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=641.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ArraySum_UInt64]
DisplayName="ArraySum (UInt64 overload)"
DescEx="<p>Returns the sum of all <var>UInt64</var> elements of array <var>A</var>.</p><p><mono>0</mono> is returned if the array is empty.</p>"
SeeAlso=ArraySum_Cardinal,ArraySum_Double,ArraySum_Extended,ArraySum_Int64,ArraySum_Integer,ArraySum_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=642.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[DigitCount]
DescEx="<p>Counts the number of digits in the given integer.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=DigitCount2,DigitCountR
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=202.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitCount2]
DescEx="<p>Counts the number of digits in the given integer.</p>"
Extra="<p>Based on code suggested by Don Rowlett.</p>"
Units=Math
SeeAlso=DigitCount,DigitCountR
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=204.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitCountR]
DescEx="<p>Counts the number of digits in the given integer using recursion.</p>"
Extra="<p>Contributed by Rubem Nascimento da Rocha.</p>"
SeeAlso=DigitCount,DigitCount2
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=417.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Factorial]
DescEx="<p>Calculates the factorial of the given number.</p>"
Extra="<p>Adapted from code contributed by Don Rowlett.</p>"
Snip=231.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsRectNormal]
DescEx="<p>Checks if the given rectangle is normalized, i.e. <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>.</p>"
Units=Windows
SeeAlso=NormalizeRect
Snip=124.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MoveRectToOrigin]
DescEx="<p>Translates the give rectangle to the origin.</p><p>The top and left co-ordinates are set to zero and the bottom and right co-ordinates are adjusted accordingly.</p>"
Units=Types
Snip=373.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[NormalizeRect]
DescEx="<p>Normalises the given rectangle so that <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>.</p>"
Extra="<p>Inspired by code published by Marco Cantù in supplementary chapter 22 of Mastering Delphi 5.</p>"
Units=Windows
Depends=ExchangeInt
SeeAlso=IsRectNormal
Snip=125.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectArea]
DescEx="<p>Returns the area of the given rectangle.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top.</p>"
SeeAlso=RectHeight,RectSize,RectWidth
Units=Windows
Snip=496.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y


[RectHeight]
DescEx="<p>Returns the height of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that height = bottom - top.</p>"
Units=Windows
SeeAlso=RectSize,RectWidth,NormalizeRect
Snip=127.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectSize]
DescEx="<p>Returns the size of the given rectangle.</p><p>The returned dimensions are always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top.</p>"
Units=Windows
Depends=RectWidth,RectHeight
SeeAlso=RectWidth,RectHeight,NormalizeRect
Snip=128.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectWidth]
DescEx="<p>Returns the width of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Extra="<p>Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left.</p>"
Units=Windows
SeeAlso=RectSize,RectHeight,NormalizeRect
Snip=126.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RepeatedDigits]
DescEx="<p>Checks if the given integer contains only a single repeated digit.</p>"
Extra="<p>An example of an integer with a single repeated digit is 5555.</p><p>Slightly modified from code contributed by Rubem Rocha.</p>"
Units=SysUtils,Math
SeeAlso=AllDigitsSame
Snip=497.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseNumber]
DescEx="<p>Reverses the digits of integer <var>AValue</var> and returns the resulting value.</p><p><var>AValue</var> should be positive: zero is always returned for negative integers.</p>"
Extra="<p>Contributed by Rubem Nascimento da Rocha.</p>"
SeeAlso=ReverseNumberR
Snip=405.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SignOfFloat]
DescEx="<p>Returns the sign of the given floating point value. Returns -1 if the value is positive, 0 if zero or +1 if negative.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=SignOfInt
Snip=205.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SignOfInt]
DescEx="<p>Returns the sign of the given integer. Returns -1 if the integer is positive, 0 if zero or +1 if negative.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=SignOfFloat
Snip=206.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SumOfLogs_Cardinal]
DisplayName=SumOfLogs (Cardinal overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Cardinal</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=643.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Double]
DisplayName=SumOfLogs (Double overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Double</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils,Math
Snip=647.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Extended]
DisplayName=SumOfLogs (Extended overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Extended</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils,Math
Snip=648.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Int64]
DisplayName=SumOfLogs (Int64 overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Int64</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Integer,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=644.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Integer]
DisplayName=SumOfLogs (Integer overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Integer</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Single,SumOfLogs_UInt64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=645.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_Single]
DisplayName=SumOfLogs (Single overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>Single</var> floating point element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0.0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_UInt64
Units=SysUtils,Math
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=649.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[SumOfLogs_UInt64]
DisplayName=SumOfLogs (UInt64 overload)
DescEx="<p>Returns the sum of the natural logarithms of each <var>UInt64</var> element of array <var>A</var>.</p><p>All elements of <var>A</var> <strong>must</strong> be positive. An exception is raised otherwise.</p><p><mono>0</mono> is returned if <var>A</var> is empty.</p>"
SeeAlso=SumOfLogs_Cardinal,SumOfLogs_Double,SumOfLogs_Extended,SumOfLogs_Int64,SumOfLogs_Integer,SumOfLogs_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Units=SysUtils
Snip=646.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[DecimalToFraction]
DescEx="<p>Converts the given decimal to a fraction. The numerator and denominator are passed out as floating point numbers in <var>FractionNumerator</var> and <var>FractionDenominator</var> respectively.</p><p><var>AccuracyFactor</var> determines how accurate the conversion is to be.</p>"
Extra="<p>Examples of <var>AccuracyFactor</var> values: 0.0005 requires accuracy of 3 decimal places and 0.000005 requires accuracy of 5 decimal places.</p> <p>Adapted from the Turbo Pascal code by John Kennedy, Mathematics Department, Santa Monica College.</p>"
Units=SysUtils,Math
Snip=468.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitSum]
DescEx="<p>Returns the sum of the digits from the given integer, using recursion.</p>"
Extra="<p>Sums of digits of negative numbers are negative, for example <mono>DigitSum(-42)=-6</mono>.</p><p>Contributed Rubem Nascimento da Rocha.</p>"
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=418.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Float]
DisplayName="DistanceBetweenPoints (TPointF overload)"
DescEx="<p>Calculates the distance between two given points with double precision floating point valued coordinates.</p>"
Depends=TPointF
SeeAlso=DistanceBetweenPoints_Int
Units=Math
Snip=495.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Int]
DisplayName="DistanceBetweenPoints (TPoint overload)"
DescEx="<p>Calculates the distance between two points with integer valued co-ordinates.</p>"
SeeAlso=DistanceBetweenPoints_Float
Units=Math,Types
Snip=494.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD]
DescEx="<p>Determines the greatest common divisor of two given non-zero integers.</p>"
Extra="<p>Uses Euclid's method.</p><p>Note that <mono>GCD(a,b) = GCD(|a|,b) = GCD(a,|b|) = GCD(|a|,|b|)</mono>, which implies that <mono>GCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD2,LCD
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=201.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD2]
DescEx="<p>Determines the greatest common divisor of two given non-zero integers.</p>"
Extra="<p>Uses a recursive implementation of Euclid's method.</p><p>Note that <mono>GCD2(a,b) = GCD2(|a|,b) = GCD2(a,|b|) = GCD2(|a|,|b|)</mono>, which implies that <mono>GCD2(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD,LCD
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=416.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime]
DescEx="<p>Checks if the given number is prime.</p>"
Extra="<p>On versions of Delphi that support <var>Int64</var> parameters to the <var>Sqrt</var> function, the type of <var>N</var>, <var>Max</var> &amp; <var>Divisor</var> can be changed to <var>Int64</var>.</p> <p>Adapted from code contributed by Don Rowlett.</p>"
SeeAlso=IsPrime2
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=232.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime2]
DescEx="<p>Checks if the given number is prime.</p>"
Extra="<p>Uses less code than <var>IsPrime</var> and does not require any floating point operations.</p><p>Contributed by daniel.</p>"
SeeAlso=IsPrime
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=570.dat
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LCD]
DescEx="<p>Returns the least common divisor of two given non-zero integers.</p>"
Extra="<p>Note that <mono>LCD(a,b) = LCD(|a|,b) = LCD(a,|b|) = LCD(|a|,|b|)</mono>, which implies that <mono>LCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
Depends=GCD
SeeAlso=GCD,GCD2
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=467.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Double]
DisplayName="MaxOfArray (Double overload)"
DescEx="<p>Returns the maximum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=428.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Extended]
DisplayName="MaxOfArray (Extended overload)"
DescEx="<p>Returns the maximum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Extended,MaxOfArray_Double,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=429.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Int64]
DisplayName="MaxOfArray (Int64 overload)"
DescEx="<p>Returns the maximum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Int64,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Integer,MaxOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=430.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Integer]
DisplayName="MaxOfArray (Integer overload)"
DescEx="<p>Returns the maximum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Integer,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=431.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Single]
DisplayName="MaxOfArray (Single overload)"
DescEx="<p>Returns the maximum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Single,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=432.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Double]
DisplayName="Mid (Double overload)"
DescEx="<p>Returns the middle of three double precision floating point values.</p>"
Units=Math
SeeAlso=Mid_Extended,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Double,MinOfArray_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=423.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Extended]
DisplayName="Mid (Extended overload)"
DescEx="<p>Returns the middle of three extended precision floating point values.</p>"
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Extended,MinOfArray_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=424.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Int64]
DisplayName="Mid (Int64 overload)"
DescEx="<p>Returns the middle of three 64 bit integer values.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Integer,Mid_Single,MaxOfArray_Int64,MinOfArray_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=425.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Integer]
DisplayName="Mid (Integer overload)"
DescEx="<p>Returns the middle of three integer values.</p>"
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Single,MaxOfArray_Integer,MinOfArray_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=426.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Single]
DisplayName="Mid (Single overload)"
DescEx="<p>Returns the middle of three single precision floating point values.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Integer,MaxOfArray_Single,MinOfArray_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=427.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Double]
DisplayName="MinMidMax (Double overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three double precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Double,MaxOfArray_Double,MinOfArray_Double
Snip=472.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Extended]
DisplayName="MinMidMax (Extended overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three extended precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Extended,MaxOfArray_Extended,MinOfArray_Extended
Snip=473.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Int64]
DisplayName="MinMidMax (Int64 overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three 64 bit integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Integer,MinMidMax_Single,Mid_Int64,MaxOfArray_Int64,MinOfArray_Int64
Snip=474.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Integer]
DisplayName="MinMidMax (Integer overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Single,Mid_Integer,MaxOfArray_Integer,MinOfArray_Integer
Snip=475.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Single]
DisplayName="MinMidMax (Single overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three single precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,Mid_Single,MaxOfArray_Single,MinOfArray_Single
Snip=476.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Double]
DisplayName="MinOfArray (Double overload)"
DescEx="<p>Returns the minimum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=433.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Extended]
DisplayName="MinOfArray (Extended overload)"
DescEx="<p>Returns the minimum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Extended,MinOfArray_Double,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=434.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Int64]
DisplayName="MinOfArray (Int64 overload)"
DescEx="<p>Returns the minimum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Int64,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Integer,MinOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=435.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Integer]
DisplayName="MinOfArray (Integer overload)"
DescEx="<p>Returns the minimum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Integer,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=436.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Single]
DisplayName="MinOfArray (Single overload)"
DescEx="<p>Returns the minimum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Single,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=437.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[NormaliseFractionSign]
DescEx="<p>Normalises the sign of the fraction with numerator <var>Num</var> and denominator <var>Denom</var> so that <var>Num</var> takes the sign of the fraction and <var>Denom</var> is non-negative.</p>"
SeeAlso=FractionToStr,FractionToStrEx
Snip=559.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Pow]
DescEx="<p>Raises integer value <var>Base</var> to non-negative integer power <var>Exponent</var> and returns the result.</p>"
SeeAlso=PowN,PowNZN,PowNZZ
Snip=561.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PowN]
DescEx="<p>IEEE compliant function that raises real number <var>X</var> to the power <var>N</var>.</p>"
Extra="<p>See IEEE standard 754-2008 for Floating-Point Arithmetic, page 44.</p>"
Units=SysUtils,Math
SeeAlso=Pow,PowNZN,PowNZZ
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=633.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[PowNZN]
DescEx="<p>Raises integer <var>X</var> to non-negative integer power <var>N</var>.</p>"
Extra="<p>Returns an <var>integer</var> value because the power <var>N</var> is non-negative which guarantees that the result is integral.</p><p>Based on IEEE standard 754-2008 for Floating-Point Arithmetic, page 44, but which restricts <var>X</var> to an integer and <var>N</var> to a non-negative integer.</p>"
SeeAlso=Pow,PowN,PowNZZ
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=634.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[PowNZZ]
DescEx="<p>Raises integer <var>X</var> to integer power <var>N</var>.</p>"
Extra="<p>Returns an <var>Extended</var> value since the result is not an integer when power <var>N</var> is negative.</p><p>Based on IEEE standard 754-2008 for Floating-Point Arithmetic, page 44, but which restricts <var>X</var> to an integer.</p>"
Units=SysUtils,
SeeAlso=Pow,PowN,PowNZN
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=635.dat
DelphiXE=Y
Delphi11A=Y
Delphi12A=Y

[ResizeRect_A]
DisplayName="ResizeRect (TSize overload)"
DescEx="<p>Resizes rectangle <var>R</var> to size <var>NewSize</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
Depends=ResizeRect_B
SeeAlso=ResizeRect_B,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=420.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ResizeRect_B]
DisplayName="ResizeRect (Longint overload)"
DescEx="<p>Resizes rectangle <var>R</var> to the width and height given by <var>NewWidth</var> and <var>NewHeight</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
SeeAlso=ResizeRect_A,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=419.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseNumberR]
DescEx="<p>Reverses the digits of the given integer, which must be non-negative, and returns the resulting value.</p><p>Uses recursion.</p>"
Extra="<p>Users of Delphi 7 and later can change the parameter and return type to <var>UInt64</var> and remove the assertion.</p><p>Slightly modified from code contributed by Rubem Nascimento da Rocha.</p>"
Units=Math
SeeAlso=ReverseNumber
Snip=406.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SAR]
DescEx="<p>Performs an arithmetic right shift operation on the given value and returns the result. <var>Value</var> is shifted right by <var>Shift</var> bits.</p><p><var>Shift</var> must be in the range <mono>0..31</mono> and is adjusted if it is not.</p>"
Extra="<p><var>SAR</var> differs from the <strong>shr</strong> operator in that it preserves any sign bit.</p><p>For more information about the different kinds of right shift operator, see this <a href="http://delphidabbler.blogspot.co.uk/2013/02/the-two-faces-of-shr.html">blog post</a>.</p>"
Snip=560.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ScaleRect]
DescEx="<p>Scales the given rectangle by the given scale factor and returns the scaled rectangle.</p>"
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Types
SeeAlso=ZoomRatio_A,ZoomRatio_B,ZoomRatio_C,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=383.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SimplifyFraction]
DescEx="<p>Simplifies the fraction with numerator <var>Num</var> and denominator <var>Denom</var> to its lowest terms.</p><p>If the fraction is already in its lowest terms then <var>Num</var> and <var>Denom</var> are left unchanged.</p>"
Depends=GCD
SeeAlso=DecimalToFraction,NormaliseFractionSign
Snip=621.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_A]
DisplayName="StretchRect (asymmetric overload)"
DescEx="<p>Stretches rectangle <var>R</var> by the given scaling factors and returns the result.</p><p>The rectangle's width is scaled by <var>ScalingX</var> and its height by <var>ScalingY</var>.</p><p>The top left corner of the rectangle is not changed.</p>"
Units=SysUtils,Types
SeeAlso=StretchRect_B,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=421.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_B]
DisplayName="StretchRect (symmetric overload)"
DescEx="<p>Stretches the rectangle <var>R</var> by scale factor <var>Scaling</var> and returns the result. Both width and height are stretched by the same scale factor.</p><p>The top left corner is not changed.</p>"
Units=Types
Depends=StretchRect_A
SeeAlso=StretchRect_A,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=422.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_A]
DisplayName="ZoomRatio (Integer overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to a rectangle of width <var>SrcWidth</var> and height <var>SrcHeight</var> to fit it, without changing the aspect ratio, within a second rectangle of width <var>DestWidth</var> and height <var>DestHeight</var>.</p>"
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Math
SeeAlso=ZoomRatio_B,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=376.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_B]
DisplayName="ZoomRatio (TSize overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to a rectangle of size <var>SrcSize</var> to fit it, without changing the aspect ratio, within a second rectangle of size <var>DestSize</var>.</p>"
Units=Types
Depends=ZoomRatio_A
SeeAlso=ZoomRatio_A,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=377.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_C]
DisplayName="ZoomRatio (TRect overload)"
DescEx="<p>Calculates and returns the largest scaling that can be applied to rectangle <var>SrcRect</var> to fit it, without changing the aspect ratio, within rectangle <var>DestRect</var>.</p>"
Units=Types
Depends=RectSize,ZoomRatio_B
SeeAlso=ZoomRatio_A,ZoomRatio_B,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=378.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ArithMean_Double]
DisplayName="ArithMean (Double overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Double</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithMean_Integer,ArithMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=650.dat
DelphiXE=Y
Delphi12A=Y

[ArithMean_Integer]
DisplayName="ArithMean (Integer overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Integer</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithMean_Double,ArithMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=651.dat
DelphiXE=Y
Delphi12A=Y

[ArithMean_Cardinal]
DisplayName="ArithMean (Cardinal overload)"
DescEx="<p>Returns the arithmetic mean of an array of <var>Cardinal</var> values.</p><p><var>EArgumentException</var> is raised if the array is empty.</p>"
Units=SysUtils
SeeAlso=ArithMean_Double,ArithMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=652.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithMean_Double]
DisplayName="WeightedArithMean (Double overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Double</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=SysUtils,Math
SeeAlso=ArithMean_Double,WeightedArithMean_Integer,WeightedArithMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=653.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithMean_Integer]
DisplayName="WeightedArithMean (Integer overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Integer</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=
Depends=WeightedArithMean_Double
SeeAlso=ArithMean_Integer,WeightedArithMean_Double,WeightedArithMean_Cardinal
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=654.dat
DelphiXE=Y
Delphi12A=Y

[WeightedArithMean_Cardinal]
DisplayName="WeightedArithMean (Cardinal overload)"
DescEx="<p>Calculates and returns the weighted average of the <var>Cardinal</var> elements of array <var>Values</var> where each element is weighted by the corresponding element in the array <var>Weights</var>.</p><p>An <var>EArgumentException</var> exception is raised if any of the following pre-conditions are not met: <var>Values</var> must be non-empty; <var>Values</var> &amp; <var>Weights</var> must have the same number of elements; all elements of <var>Weights</var> must be non-negative, with at least one element being non-zero.</p>"
Units=
Depends=WeightedArithMean_Double
SeeAlso=ArithMean_Cardinal,WeightedArithMean_Double,WeightedArithMean_Integer
TestInfo=advanced
AdvancedTest.Level=unit-tests
AdvancedTest.URL="https://github.com/delphidabbler/code-snippets/tree/master/tests/Cat-Maths"
Snip=655.dat
DelphiXE=Y
Delphi12A=Y
