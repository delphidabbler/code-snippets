# DelphiDabbler Code Snippets Database v2
#
# String Management category file
#
# This file is licensed under the MIT license, copyright © 2020 Peter Johnson,
# https://gravatar.com/delphidabbler

[AddThousandSeparator]
DescEx="<p>Adds the &quot;thousands separator&quot; specified by <var>C</var> at the correct location(s) in string <var>S</var> and returns the result.</p><p><var>S</var> is assumed to be the string representation of a positive whole number.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=AddDefThousandSeparator
Snip=162.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ContainsDelims]
DescEx="<p>Checks if string <var>S</var> contains any of the characters from the <var>Delimiters</var> string.</p><p>Returns True if any delimiter character is found or False if not.</p>"
Units=SysUtils
SeeAlso=CountDelims,ContainsWhiteSpace
Snip=238.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CountDelims]
DescEx="Returns the number of occurences of any character from <var>Delims</var> in the given string <var>S</var>."
Units=SysUtils
SeeAlso=ContainsDelims
Snip=032.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CountUnquotedWords]
DescEx="Returns the number of <em>space</em> delimited words in string <var>S</var>. Any words enclosed by the quote character <var>AQuote</var> are counted as one word."
Extra="<p>Contributed by Rubem Rocha.</p>"
Units=Classes
SeeAlso=ExplodeUnquotedWords,CountWords,WordCount
Snip=183.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DelAllStr]
DescEx="<p>Deletes all occurrences of sub-string <var>Needle</var> from string <var>HayStack</var> and returns the resulting string.</p><p><var>HayStack</var> is returned unchanged if it does not contain <var>Needle</var>.</p><p>The search is case sensitive.</p>"
Extra="<p>Renamed from a routine contributed by Bill Miller.</p>"
SeeAlso=DelAllText,DelStr,DelText
Units=SysUtils
Snip=477.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DelAllText]
DescEx="<p>Deletes all occurrences of text <var>Needle</var> from text <var>HayStack</var> and returns the resulting string.</p><p><var>HayStack</var> is returned unchanged if it does not contain <var>Needle</var>.</p><p>The search is case insensitive.</p>"
Extra="<p>Renamed from a routine contributed by Bill Miller.</p>"
SeeAlso=DelAllStr,DelStr,DelText
Units=SysUtils
Snip=478.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DelStr]
DescEx="<p>Deletes the first occurrence of sub-string <var>Needle</var> from string <var>HayStack</var> and returns the resulting string.</p><p><var>HayStack</var> is returned unchanged if it does not contain <var>Needle</var>.</p><p>The search is case sensitive.</p>"
Extra="<p>Renamed from a routine contributed by Bill Miller.</p>"
SeeAlso=DelAllStr,DelAllText,DelText
Units=SysUtils
Snip=479.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DelText]
DescEx="<p>Deletes the first occurrence of text <var>Needle</var> from text <var>HayStack</var> and returns the resulting string.</p><p><var>HayStack</var> is returned unchanged if it does not contain <var>Needle</var>.</p><p>The search is case insensitive.</p>"
Extra="<p>Renamed from a routine contributed by Bill Miller.</p>"
SeeAlso=DelAllStr,DelAllText,DelStr
Units=SysUtils
Snip=480.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSLineBreaks]
DescEx="<p>Converts all Unix and Mac line endings in the given string to DOS line endings and returns the result.</p>"
Extra="<p>Any existing DOS line breaks are preserved.</p>"
Units=SysUtils
SeeAlso=UnixLineBreaks
Snip=190.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeUnquotedWords]
DescEx="<p>Extracts a list of space delimited words from string <var>S</var> and returns the number of words found. The extracted words are stored in stringlist <var>List</var>, overwriting any existing contents.</p><p>Any words enclosed by the quote character <var>AQuote</var> are kept together as one word.</p>"
Extra="<p>Contributed by Rubem Rocha.</p>"
Units=Classes
SeeAlso=ExplodeWords,ExplodeStr
Snip=181.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsValidDouble]
DescEx="<p>Checks if the given string represents a valid double precision floating point number.</p>"
Units=SysUtils
SeeAlso=IsValidExtended,IsValidSingle
Snip=454.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsValidExtended]
DescEx="<p>Checks if the given string represents a valid extended precision floating point number.</p>"
Units=SysUtils
SeeAlso=IsValidDouble,IsValidSingle
Snip=455.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsValidSingle]
DescEx="<p>Checks if the given string represents a valid single precision floating point number.</p>"
Units=SysUtils
SeeAlso=IsValidDouble,IsValidExtended
Snip=456.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[JoinStr]
DescEx="<p>Joins all strings in string list <var>SL</var> together into a single string, which is returned.</p><p>Strings are separated by delimiter text <var>Delim</var>. Empty strings are ignored unless <var>AllowEmpty</var> is True, when they cause a delimiter to be appended to the result string.</p>"
Units=Classes
SeeAlso=ExplodeStr,ExplodeStrArray,JoinStrArray,SplitStr
Snip=031.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[JoinStrArray]
DescEx="<p>Joins all strings in string array <var>Strings</var> together into a single string, which is returned.</p><p>Strings are separated by delimiter text <var>Delim</var>. Empty strings are ignored unless <var>AllowEmpty</var> is True, when they cause a delimiter to be appended to the result string.</p>"
SeeAlso=ExplodeStr,ExplodeStrArray,JoinStr,SplitStr
Snip=535.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LastChar]
DescEx="<p>Returns the last character of the given string.</p><p>It is an error if the string is empty.</p>"
Extra="<p>This routine is not suitable for use with multi-byte character sets.</p><p>Contributed by Guru Kathiresan.</p>"
SeeAlso=StripLastChar
Snip=381.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LastPos]
DescEx="<p>Finds and returns the position of the last occurence of sub string <var>SubStr</var> in string <var>Str</var>.</p><p>Returns 0 if <var>SubStr</var> is not found.</p>"
Units=StrUtils
Snip=194.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=N
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MultiSzToStrings]
DescEx="<p>Splits out individual strings from the &quot;multi string&quot; buffer <var>MultiSz</var> and appends each string to string list <var>Strings</var>.</p><p><var>MultiSz</var> must point to a buffer containing a sequence of <mono>#0</mono> terminated strings followed by an additional <mono>#0</mono> character that indicates the end of the buffer.</p><p>Does nothing if either <var>Strings</var> or <var>MultiSz</var> are nil.</p>"
Units=Classes,SysUtils
SeeAlso=StringsToMultiSz
Snip=062.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AddDefThousandSeparator]
DescEx="<p>Adds the thousands separator for the current locale at the correct location(s) in string <var>S</var> and returns the result.</p><p><var>S</var> is assumed to be the string representation of a positive whole number.</p>"
Extra="<p>Users of Delphi XE &amp; later or Free Pascal 2.6.0 &amp; later should use <var>AddDefThousandSeparatorXE</var> instead of this routine.</p>"
Units=SysUtils
Depends=AddThousandSeparator
SeeAlso=AddThousandSeparator,AddDefThousandSeparatorXE
Snip=163.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=N
DelphiXE4=N
DelphiXE5=N
DelphiXE6=N
DelphiXE7=N
DelphiXE8=N
Delphi10S=N
FPC=Y

[AddDefThousandSeparatorXE]
DescEx="<p>Adds the thousands separator for the current locale at the correct location(s) in string <var>S</var> and returns the result.</p><p><var>S</var> is assumed to be the string representation of a positive whole number.</p>"
Extra="<p>This is a version of <var>AddDefThousandSeparator</var> suitable for use with Delphi XE &amp; later or Free Pascal 2.6.0 &amp; later. For Delphi 2010 and earlier, use <var>AddDefThousandSeparator</var> instead.</p>"
Units=SysUtils
Depends=AddThousandSeparator
SeeAlso=AddThousandSeparator,AddDefThousandSeparator
Snip=555.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=N
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=N
Delphi2010=N
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AnsiStringToCharSet]
DescEx="<p>Creates and returns a set of all the unique characters from the given ANSI string.</p>"
Extra="<p><warning>Note:</warning> This function works <strong>does not</strong> work with multi-byte ANSI strings: it assumes a character occupies exactly one byte.</p>"
Depends=RawByteString,TCharSet
Snip=363.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CEscapeStr]
DescEx="<p>Returns a copy of string <var>S</var> which has each character appearing in <var>EscapableChars</var> replaced by an escape sequence comprising the character <mono>'\'</mono> followed by the matching character from <var>EscapeChars</var>.</p>"
Extra="<p>Note that <var>EscapeChars</var> and <var>EscapableChars</var> must be the same length and <var>EscapeChars[X]</var> should be the escaped equivalent of <var>EscapableChars[X]</var>. For example, if you wish to escape <mono>CR</mono>, <mono>LF</mono>, <mono>TAB</mono> and <mono>\</mono> to <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> respectively, set <var>EscapableChars</var> to <mono>#13#10#9'\'</mono> and <var>EscapeChars</var> to <mono>'rnt\'</mono>.</p>"
Units=SysUtils
SeeAlso=CUnEscapeStr
Snip=102.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ChangeChar]
DescEx="Replaces all occurrences the character <var>ASearch</var> in <var>AString</var> with the <var>AReplace</var> character, and returns the resulting string."
Extra="<p><warning>Warning:</warning> This routine replaces code points rather than characters. It is <strong>not safe</strong> for use with ANSI multi-byte character sets or, on Unicode versions of Delphi, with characters outside the Unicode <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">basic multilingual plane</a>.</p><p>Contributed by Bill Miller.</p>"
Snip=349.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CompareNumberStr]
DescEx="<p>Compares two strings, <var>S1</var> and <var>S2</var>, treating any whole, non-negative, numbers embedded in the strings as numbers rather than text. Text comparisons are case sensitive.</p><p>Returns a negative value if <var>S1</var> &lt; <var>S2</var>, a positve value if <var>S1</var> &gt; <var>S2</var> or 0 if <var>S1</var> and <var>S2</var> are equal.</p>"
Extra="<p><strong>Note 1:</strong> this routine is not safe for use with multi-byte character sets (ANSI strings) or with strings containing characters outside the Basic Multilingual Plane (Unicode strings).</p><p><strong>Note 2:</strong> the routine does not recognise the <mono>+</mono> and <mono>-</mono> unary operators so performs a string comparison on them. This means that, for example, <mono>'+12'</mono> will appear to be less than <mono>'-12'</mono>, because the string <mono>'+'</mono> is less than <mono>'-'</mono>.</p>"
Units=SysUtils
Depends=IsASCIIDigit
Snip=611.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CompressWhiteSpace]
DescEx="<p>Returns a copy of the given string where each sequence of one or more white space characters is replaced by a single space character.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
Depends=IsWhiteSpace
SeeAlso=ContainsWhiteSpace,IsWhiteSpace,StripWhiteSpace
Snip=035.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ContainsWhiteSpace]
DescEx="<p>Checks if the given string contains any white space.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Depends=ContainsDelims
SeeAlso=ContainsDelims,CompressWhiteSpace,IsWhiteSpace,StripWhiteSpace
Snip=239.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CountWords]
DescEx="<p>Returns the number of white space delimited words in the given string.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=Classes
Depends=ExplodeWords
SeeAlso=CountUnquotedWords,WordCount
Snip=182.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CUnEscapeStr]
DescEx="<p>Returns a copy of string <var>S</var> where each C-style escape sequence, introduced by <mono>'\'</mono> and followed by a character from <var>EscapeChars</var>, is replaced by the corresponding character from <var>EscapableChars</var>.</p><p>If an unrecognised escape character is found it is copied literally, stripped of its preceeding <mono>'\'</mono>.</p>"
Extra="<p>Note that <var>EscapeChars</var> and <var>EscapableChars</var> must be the same length and <var>EscapeChars[X]</var> should be the escaped equivalent of <var>EscapableChars[X]</var>. For example, if you wish to unescape <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> as <mono>CR</mono>, <mono>LF</mono>, <mono>TAB</mono> and <mono>\</mono> set <var>EscapeChars</var> to <mono>'rnt\'</mono> and <var>EscapableChars</var> to <mono>#13#10#9'\'</mono>.</p>"
Units=SysUtils
SeeAlso=CEscapeStr,IsValidCEscapedStr
Snip=103.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CutWordByIndex]
DescEx="<p>Deletes the <var>N</var>th word from string <var>Str</var> and returns the deleted word. Words are delimited by any of the characters in <var>Delims</var>.</p><p>If there is no <var>N</var>th word then the empty string is returned and <var>Str</var> is not modified.</p>"
Extra="<p>Slightly modified from code contributed by Bill Miller.</p>"
Depends=GetStartAndEndWord,TCharSet
SeeAlso=DeleteWordByIndex,GetWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=304.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DeleteWordByIndex]
DescEx="<p>Deletes and discards the <var>N</var>th word from string <var>Str</var>. Words are delimited by any of the characters in <var>Delims</var>.</p><p>Returns True if the <var>N</var>th word was found and deleted from <var>Str</var> or False if there is no <var>N</var>th word and <var>Str</var> is unchanged.</p>"
Depends=GetStartAndEndWord
SeeAlso=CutWordByIndex,GetWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=305.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeStr]
DescEx="<p>Splits the string <var>S</var> into segments separated by delimiter <var>Delim</var> and stores each segment in turn in string-list <var>List</var>, replacing any existing content.</p><p>If <var>Trim</var> is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if <var>AllowEmpty</var> is False.</p><p>The number of segments added to <var>List</var> is returned.</p>"
Extra="<p>If <var>AllowEmpty</var> is False and <var>Trim</var> is True then empty strings and those made up of only white space are ignored.</p>"
Units=Classes
Depends=SplitStr
SeeAlso=ExplodeStrArray,JoinStr,JoinStrArray,SplitStr,TrimStringList,ExplodeWords,ParseStr,SplitString
Snip=034.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeStrArray]
DescEx="<p>Splits the string <var>S</var> into segments separated by delimiter <var>Delim</var> and returns a string array containing the segments.</p><p>If <var>Trim</var> is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if <var>AllowEmpty</var> is False.</p>"
Extra="<p>If <var>AllowEmpty</var> is False and <var>Trim</var> is True then empty strings and those made up of only white space are ignored.</p>"
Units=Classes,Types
Depends=ExplodeStr,StringListToArray
SeeAlso=ExplodeStr,JoinStr,JoinStrArray,SplitStr,TrimStringList,ExplodeWords
Snip=348.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeWords]
DescEx="Extracts a list of white space delimited words from string <var>S</var> and returns the number of words found. The extracted words are stored in stringlist <var>Words</var>, overwriting any existing content."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=Classes
Depends=ExplodeStr,CompressWhiteSpace
SeeAlso=ExplodeStr,ExplodeUnquotedWords
Snip=180.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetFirstWord]
DescEx="<p>Returns the first word of string <var>S</var> where words are delimited by the character supplied in <var>Delim</var>.</p><p>If <var>Delim</var> is the <em>space</em> character (the default) then any sequence of white space will act as the word delimiter.</p>"
Extra="<p><warning>Warning:</warning> If you want to use white space as the word delimiter always specify the <em>space</em> character as the value of <var>Delim</var>. Any other white space character (as defined below) will not work as a delimiter.</p><p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p><p>Slightly modified from code contributed by Bill Miller.</p>"
Units=Classes
Depends=CompressWhiteSpace,ExplodeStr
SeeAlso=GetLastWord
Snip=192.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetLastWord]
DescEx="<p>Returns the last word of string <var>S</var> where words are delimited by the character supplied in <var>Delim</var>.</p><p>If <var>Delim</var> is the <em>space</em> character (the default) then any sequence of white space will act as the word delimiter.</p>"
Extra="<p><warning>Warning:</warning> If you want to use white space as the word delimiter always specify the <em>space</em> character as the value of <var>Delim</var>. Any other white space character (as defined below) will not work as a delimiter.</p><p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p><p>Slightly modified from code contributed by Bill Miller.</p>"
Units=Classes
Depends=CompressWhiteSpace,ExplodeStr
SeeAlso=GetFirstWord
Snip=193.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetStartAndEndWord]
DescEx="<p>Finds the location of the <var>N</var>th word in string <var>Str</var> and passes the start and end of the location out in <var>StartIdx</var> and <var>EndIdx</var>. Words are delimited by the any of the characters in <var>Delim</var>.</p><p>Returns True if the <var>N</var>th word was found or False, with <var>StartIdx</var> set to 0, if not.</p>"
Extra="<p>Modified from code contributed by Bill Miller.</p>"
Units=SysUtils
Depends=IsCharInSet,TCharSet
Snip=303.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetWordByIndex]
DescEx="<p>Locates and returns the <var>N</var>th word from string <var>Str</var>. Words are delimited by the any of the characters in <var>Delim</var>.</p><p>If there is no Nth word then the empty string is returned.</p>"
Depends=GetStartAndEndWord,TCharSet
SeeAlso=CutWordByIndex,DeleteWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=306.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[InString]
DescEx="<p>Checks if string <var>Needle</var> is contained in <var>Haystack</var> and returns True if so or False if not.</p><p>Checking is case insensitive if <var>IgnoreCase</var> is True.</p>"
Extra="<p>Contributed by Alan Bailey.</p>"
Units=SysUtils
Snip=612.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsHexStr]
DescEx="<p>Checks if the given string contains only valid hex digits. Returns True if so or False otherwise.</p>"
Units=SysUtils
Depends=IsCharInSet
Snip=100.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsNumeric]
Units=SysUtils
DescEx="<p>Checks if the string <var>Value</var> contains a valid numeric value and returns True if so or False if not.</p><p>If <var>AllowFloat</var> is true then <var>Value</var> may contain a floating point number, otherwise it must be an integer. If <var>TrimWhiteSpace</var> is True any white space surrounding <var>Value</var> is trimmed before testing.</p>"
Extra="<p>Floating point numbers can be in normal or scientific notation.</p><p>Integers can be expressed as decimal or hexadecimal numbers, with hex numbers prefixed by either <mono>'$'</mono> or <mono>'0x'</mono>.</p>"
TestInfo=advanced
Snip=132.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsValidCEscapedStr]
DescEx="<p>Checks if any C-style escape characters in string <var>S</var> match those given by <var>ValidEscChars</var>.</p><p>Returns True if so and False if not.</p>"
Extra="<p><strong>Note 1:</strong> A &quot;C-style&quot; escape character begins with a <mono>\</mono> character.</p><p><strong>Note 2:</strong> This function does not support escape sequences longer than one character: e.g. it supports <mono>\n</mono> but not <mono>\045</mono>.</p><p><strong>Example:</strong> To check that a string contains only the escape sequences <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> set <var>ValidEscChars</var> to <mono>'rnt\'</mono>.</p>"
Units=SysUtils
SeeAlso=CEscapeStr,CUnEscapeStr
Snip=101.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsWhiteSpace]
DescEx="<p>Checks if the given character is white space.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
SeeAlso=CompressWhiteSpace,ContainsWhiteSpace,StripWhiteSpace
Depends=IsCharInSet
Snip=133.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PadCenter]
DescEx="Centre aligns string <var>AString</var> within a string of size <var>AWidth</var> and returns the result. The string is padded as necessary with character <var>AChar</var>."
Extra="<p>When an odd number of padding characters is required, the extra character is added on the right.</p>"
SeeAlso=PadLeft,PadRight
Snip=246.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PadLeft]
DescEx="Left aligns string <var>AString</var> within a string of size <var>AWidth</var> and returns the result. The string is padded on the right as necessary with character <var>AChar</var>."
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=PadCenter,PadRight
Snip=247.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PadRight]
DescEx="<p>Right aligns string <var>AString</var> within a string of size <var>AWidth</var> and returns the result. The string is padded on the left as necessary with character <var>AChar</var>.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
SeeAlso=PadCenter,PadLeft
Snip=248.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ParseDelims]
DescEx="<p>Returns the sub-string of string <var>TextLine</var> that begins at <var>StartPos</var> and is terminated by one of the delimiting characters from <var>Delims</var> or the end of the string.</p><p><var>StartPos</var> is updated to the index of the character after the delimiter.</p><p>Returns the empty string if there is no sub-string following <var>StartPos</var>.</p>"
Units=SysUtils
Snip=004.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseStr]
DescEx="<p>Returns the reverse of the given string.</p>"
Extra="<p>Renamed from a routine contributed by Rubem Nascimento da Rocha.</p>"
Units=SysUtils,StrUtils
SeeAlso=ReverseStrR
TestInfo=advanced
Snip=438.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseStrR]
DescEx="<p>Returns the reverse of the given string.</p>"
Extra="<p>Uses recursion.</p><p>Renamed from a routine contributed by Rubem Nascimento da Rocha.</p>"
Units=SysUtils,StrUtils
SeeAlso=ReverseStr
TestInfo=advanced
Snip=439.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SplitStr]
DescEx="<p>Splits string <var>S</var> at the first occurence of delimiter string <var>Delim</var>. <var>S1</var> is set to to the sub-string of <var>S</var> before <var>Delim</var> and <var>S2</var> to the remainder of <var>S</var> after <var>Delim</var>.</p><p>If <var>Delim</var> is not found then <var>S1</var> is set to <var>S</var> and <var>S2</var> to the empty string.</p><p>Returns True if <var>S</var> contains <var>Delim</var> or False if not.</p>"
Units=SysUtils
SeeAlso=ExplodeStr,ExplodeStrArray,JoinStr,JoinStrArray
Snip=033.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StripAccelChars]
DescEx="Strips all accelerator ('<mono>&amp;</mono>') characters from the given string and returns the resulting string."
Extra="<p>Renamed from a routine contributed by Rubem Nascimento da Rocha.</p>"
Units=SysUtils
TestInfo=advanced
Snip=440.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StripLastChar]
DescEx="Removes the last character from the string <var>S</var> and returns the resulting string. If <var>S</var> is empty then it is returned unchanged."
Extra="<p><strong>Note:</strong> This routine is not suitable for use with multi-byte character sets.</p><p>Contributed by Guru Kathiresan.</p>"
SeeAlso=LastChar
Snip=382.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StrToken]
DescEx="<p>Finds and returns the first token in string <var>S</var>, delimited by the given separator character. The token and separator are removed from <var>S</var>.</p><p>If no separators are found then the whole of <var>S</var> is returned and <var>S</var> is then set to the empty string.</p>"
Extra="<p>Slightly modified from code contributed by Guru Kathiresan.</p>"
Units=SysUtils
SeeAlso=StrTokenCount
Snip=537.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StrTokenCount]
DescEx="<p>Counts and returns the number of tokens in string <var>S</var> delimited by the given separator character.</p><p>Empty strings before separators are counted as tokens, but an empty string after the last separator is not.</p>"
Extra="<p>Contributed by Guru Kathiresan.</p>"
SeeAlso=StrToken
Depends=StrToken
Snip=538.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TextWrap]
DescEx="<p>Word wraps string <var>Text</var>, using the <em>space</em> character as delimiter, into lines of maximum width <var>Width</var>, with each line left-padded with <var>Margin</var> spaces.</p><p>The resulting text is returned in a string with lines separated by <mono>CRLF</mono>.</p>"
Units=Classes
Depends=ExplodeStr
Snip=141.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimChar]
DescEx="Trims occurrences of character <var>C</var> from both ends of string <var>S</var> and returns the result."
Extra="<p>The character to be trimmed must be a single byte character.</p>"
Depends=TrimLeftChar,TrimRightChar
SeeAlso=TrimLeftChar,TrimRightChar
Snip=195.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimLeftChar]
DescEx="Trims occurrences of character <var>C</var> from the start of string <var>S</var> and returns the result."
Extra="<p>The character to be trimmed must be a single byte character.</p>"
SeeAlso=TrimChar,TrimRightChar
Snip=196.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimRightChar]
DescEx="Trims occurrences of character <var>C</var> from the end of string <var>S</var> and returns the result."
Extra="<p>The character to be trimmed must be a single byte character.</p>"
SeeAlso=TrimChar,TrimLeftChar
Snip=197.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimStringList]
DescEx="<p>Removes lines prefixed by <var>Prefix</var> from string list <var>List</var>, updating it in place.</p><p>Set <var>Prefix</var> to the empty string to remove empty lines, including those containing only white space.</p>"
Extra="<p>Closely based on a routine contributed by Joe Donth.</p>"
Units=SysUtils,Classes
SeeAlso=ExplodeStr,JoinStr
Snip=131.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[UnixLineBreaks]
DescEx="<p>Converts all DOS and Mac line endings in the given string to Unix line endings and returns the result.</p>"
Extra="<p>Any existing Unix line breaks are preserved.</p>"
Units=SysUtils
SeeAlso=DOSLineBreaks
Snip=191.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ParseStr]
DescEx="<p>Splits the string <var>StrToParse</var> into segments separated by <var>Delimiter</var> and stores each segment in turn in string list <var>Words</var>, replacing any existing content.</p>"
Extra="<p>If <var>StrToParse</var> contains adjacent <var>Delimiter</var> characters with no text between them then an empty element is added to the string list. Leading and trailing <var>Delimiter</var> characters cause an empty element to be added at the beginning and end of the string list respectively. For example <mono>ParseStr('|foo||bar|', '|', Words);</mono> causes <var>Words</var> to contain the five elements <mono>''</mono>, <mono>'foo'</mono>, <mono>''</mono>, <mono>'bar'</mono> and <mono>''</mono>.</p><p>Contributed by Mark Billig.</p>"
Units=Classes
SeeAlso=ExplodeStr,ParseDelims,SplitStr,SplitString
TestInfo=advanced
Snip=626.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PosByIndex]
DescEx="<p>Returns the start position of the <var>N</var>th word in string <var>Str</var>. Words are delimited by any of the characters in <var>Delim</var>.</p><p>Returns 0 if there is no such word.</p>"
Extra="<p>Slightly modified from code contributed by Bill Miller.</p>"
Depends=GetStartAndEndWord
SeeAlso=CutWordByIndex,DeleteWordByIndex,GetWordByIndex,ReplaceWordByIndex
Snip=307.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[QuoteSpacedString]
DescEx="If string <var>S</var> contains white space it is surrounded in the quotes specified by <var>Quote</var> and the result is returned. If <var>S</var> does not contain white space it is returned unchanged."
Extra="<p>Any quote characters already contained within the string are left unchanged: they are not escaped.</p><p><strong>Note:</strong> This function recognises only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Depends=ContainsWhiteSpace
Snip=249.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReduceStr]
DescEx="Reduces the length of string <var>S</var> by the number of characters given by <var>ReduceBy</var> and returns the result."
Extra="<p><warning>Warning:</warning> This function actually operates on code points rather than characters, making it unsafe for use with ANSI multi-byte character sets or characters outside the Unicode <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">basic multilingual plane</a>.</p><p>Contributed by Bill Miller.</p>"
Snip=350.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReplaceWordByIndex]
DescEx="<p>Replaces the <var>N</var>th word from string <var>Str</var> with <var>NewWord</var>. Words are delimited by the any of the characters in <var>Delim</var>.</p><p>Modifies <var>Str</var> and returns True on success. Returns False and leaves <var>Str</var> unchanged if there is no <var>N</var>th word.</p>"
Extra="<p>Inspired by code contributed by Bill Miller.</p>"
Depends=GetStartAndEndWord
SeeAlso=CutWordByIndex,DeleteWordByIndex,GetWordByIndex,PosByIndex
Snip=308.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RemoveDuplicateStrings]
DescEx="<p>Removes duplicate strings from the given string list.</p><p>The modified string list will be sorted.</p>"
Extra="<p>Modified from code contributed by Bill Miller.</p>"
SeeAlso=StripDuplicateStrings
Units=Classes
Snip=616.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SplitPathList_A]
DisplayName="SplitPathList (TStrings overload)"
DescEx="<p>Splits <var>PathList</var>, which must contain semi-colon delimited file paths, into individual paths and appends each one to string list <var>Paths</var>.</p>"
Extra="<p>Empty paths (represented by <mono>';;'</mono>), or those comprising only spaces, are ignored. Leading and trailing spaces are removed from paths (e.g. <mono>' C:\MyFile '</mono> is read as <mono>'C:\MyFile'</mono>).</p>"
Units=Classes
Depends=ExplodeStr
SeeAlso=SplitPathList_B
Snip=410.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SplitPathList_B]
DisplayName="SplitPathList (string array overload)"
DescEx="<p>Splits <var>PathList</var>, which must contain semi-colon delimited file paths, into individual paths and returns a string array containing them.</p>"
Extra="<p>Empty paths (represented by <mono>';;'</mono>), or those comprising only spaces, are ignored. Leading and trailing spaces are removed from paths (e.g. <mono>' C:\MyFile '</mono> is read as <mono>'C:\MyFile'</mono>).</p>"
Units=Types
Depends=ExplodeStrArray
SeeAlso=SplitPathList_A
Snip=411.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SplitString]
DescEx="<p>Splits the string <var>AText</var> into segments separated by <var>Delimiter</var> and creates and returns a string list containing the segments.</p><p>The caller is responsible for freeing the returnd string list object.</p>"
Extra="<p>If <var>AText</var> contains adjacent <var>Delimiter</var> strings with no text between them then an empty element is added to the string list. For example <mono>SplitString('foo||bar', '|');</mono> returns a string list containing the 3 elements <mono>'foo'</mono>, <mono>''</mono> and <mono>'bar'</mono>.</p><p>However if <var>AText</var> ends with one or more <var>Delimiter</var> strings then no blank element is added to the result for the last occurrence of <var>Delimiter</var>, e.g. <mono>SplitString('foo|bar|', '|');</mono> returns a string list containing just the 2 elements <mono>'foo'</mono> and <mono>'bar'</mono> while <mono>SplitString('foo|bar||', '|');</mono> returns the 3 element string list <mono>'foo'</mono>, <mono>'bar'</mono> and <mono>''</mono>.</p><p>Contributed by Daniel.</p>"
Units=SysUtils,Classes
SeeAlso=ExplodeStr,ParseDelims,ParseStr,SplitStr
TestInfo=advanced
Snip=627.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StringsToMultiSz]
DescEx="<p>Converts the strings from stringlist <var>Strings</var> into &quot;multi-string&quot; format and stores the result in the buffer pointed to by <var>MultiSz</var>, which must be at least <var>BufSize</var> characters in size.</p><p>Strings written to <var>MultiSz</var> are terminated by <mono>#0</mono> and an additional <mono>#0</mono> character terminates the list.</p><p>Returns 0 on success or the required buffer size, in characters, if <var>BufSize</var> is too small or if <var>MultiSz</var> is nil.</p>"
Extra="<p>To find the size of the <var>MultiSz</var> buffer required to accomodate all the strings from <var>Strings</var> first call <var>StringsToMultiSz</var> with <var>MultiSz</var> = <strong>nil</strong> and <var>BufSize</var> = 0. The required buffer size, in characters, will be returned.</p><p><strong>Note:</strong> The <var>BufSize</var> parameter and return value of <var>StringsToMultiSz</var> express buffer sizes in <em>characters</em>. For compilers using Unicode strings this is not the same as the buffer size in bytes.</p>"
Units=Classes,SysUtils
SeeAlso=MultiSzToStrings
Snip=063.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StripDuplicateStrings]
DescEx="<p>Returns a string array that is a copy of given array <var>SA</var> with duplicates removed.</p><p>The returned array will be sorted.</p>"
SeeAlso=RemoveDuplicateStrings
Depends=ArrayToStringList,RemoveDuplicateStrings,StringListToArray
Units=Classes,Types
Snip=617.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StripWhiteSpace]
DescEx="<p>Removes all white space from the given string and returns the result.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
Depends=IsWhiteSpace
SeeAlso=CompressWhiteSpace,ContainsWhiteSpace,IsWhiteSpace
Snip=536.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TitleCase]
DescEx="<p>Converts the given string to title case and returns the result.</p>"
Extra="<p>This function assumes the use of the English language.</p><p>True <a href="http://en.wikipedia.org/wiki/Title_case">title case</a> should ignore minor words, like &quot;and&quot; and &quot;the&quot; but this function, like many others, doesn't do that.</p>"
Units=SysUtils
Depends=IsWhiteSpace,IsCharInSet
Snip=134.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[WordCount]
DescEx="<p>Returns the number of white space delimited words in the given string.</p>"
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
Depends=CountDelims,CompressWhiteSpace
SeeAlso=CountWords,CountUnquotedWords
Snip=184.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
