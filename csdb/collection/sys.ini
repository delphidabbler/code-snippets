# DelphiDabbler Code Snippets Database v2
#
# System category file
#
# This file is licensed under the MIT license, copyright © 2020 Peter Johnson,
# https://gravatar.com/delphidabbler

[DebuggerPresent]
DescEx="<p>Indicates whether the calling process is running within a debugger.</p>"
Extra="<p>Contributed by DennisLV.</p>"
Units=Windows
Snip=136.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Delay]
DescEx="<p>Delays processing for the given number of milliseconds without processing any messages.</p>"
Extra="<p>This routine is aimed at console applications and threads that have no message queue. Normal GUI applications should not use this routine.</p><p>Modified in line with Pause routine per suggestions by Montor.</p>"
Units=Windows
SeeAlso=Pause
Snip=265.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[EmptyKeyQueue]
DescEx="<p>Empties all keyboard messages from the message queue of any window belonging to the current thread.</p>"
Extra="<p>Contributed by DennisLV.</p>"
Units=Windows,Messages
SeeAlso=SendKeysToWindow
Snip=120.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetBiosVendor]
DescEx="<p>Returns the name of the computer's BIOS vendor.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
Units=Windows,Registry
SeeAlso=GetProcessorIdentifier,GetProcessorName,GetSystemManufacturer,GetSystemProductName
Snip=511.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetCharFromVirtualKey]
DescEx="<p>Translates virtual key code <var>AKey</var> into one or more characters which are returned as a string.</p><p>An empty string is returned if <var>AKey</var> can't be translated.</p>"
Extra="<p>Adapted from code contributed by Bill Miller.</p>"
Units=Windows
Snip=203.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetParentProcessID]
DescEx="Returns the ID of the process that is the parent of the process identified by <var>PID</var>."
Units=Windows,TlHelp32
SeeAlso=GetWindowProcessID
Snip=240.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetProcessName]
DescEx="<p>Returns the name of the executable file associated with the process identified by <var>PID</var>, or the empty string on error.</p>"
Units=Windows,TlHelp32
SeeAlso=GetWindowProcessID,GetWindowProcessName
Snip=159.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetProcessorIdentifier]
DescEx="<p>Returns the identifier of the computer's processor.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
Units=Windows,Registry
SeeAlso=GetBiosVendor,GetProcessorName,GetSystemManufacturer,GetSystemProductName
Snip=512.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetProcessorName]
DescEx="<p>Return the name of the computer's processor.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
Units=Windows,Registry
SeeAlso=GetBiosVendor,GetProcessorIdentifier,GetSystemManufacturer,GetSystemProductName
Snip=513.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetSystemManufacturer]
DescEx="<p>Returns the name of the computer's manufacturer.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
Units=Windows,Registry
SeeAlso=GetBiosVendor,GetProcessorIdentifier,GetProcessorName,GetSystemProductName
Snip=514.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetSystemProductName]
DescEx="<p>Returns the system product name.</p>"
Extra="<p>Contributed by Bill Miller.</p>"
Units=Windows,Registry
SeeAlso=GetBiosVendor,GetProcessorIdentifier,GetProcessorName,GetSystemManufacturer
Snip=515.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetWindowProcessID]
DescEx="<p>Returns the ID of the process that created the window with handle <var>Wnd</var>, or -1 if <var>Wnd</var> is not a valid window handle.</p>"
Units=Windows
SeeAlso=GetProcessName,GetWindowProcessName,GetParentProcessID
Snip=158.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetWindowProcessName]
DescEx="<p>Returns the name of the executable file of the process that created the window with handle <var>Wnd</var>, or the empty string on error.</p>"
Units=Windows
Depends=GetProcessName,GetWindowProcessID
SeeAlso=GetProcessName,GetWindowProcessID
Snip=160.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetWindowThreadID]
DescEx="Returns the identifier of the thread that created the window with handle <var>Wnd</var>, or -1 if <var>Wnd</var> is invalid or if the thread can't be found."
Units=Windows
SeeAlso=GetWindowProcessID
Snip=241.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[HostIPAddress]
DescEx="<p>Detects and returns the machine's local IP address, or <mono>0.0.0.0</mono> if the address is not found.</p>"
Extra="<p>Contributed by DennisLV.</p>"
Units=SysUtils,Windows,WinSock
Snip=108.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsAdmin]
DescEx="<p>Checks if the current user has administrator privileges.</p>"
Extra="<p>Contributed by Rubem Nascimento da Rocha.</p>"
Units=Windows
Snip=404.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsKeyPressed]
DescEx="<p>Checks if the key identified by <var>VirtKeyCode</var> is being pressed.</p><p><var>VirtKeyCode</var> must be either a virtual key code or an ASCII value.</p>"
Units=Windows
SeeAlso=IsLockKeyOn
Snip=135.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsLockKeyOn]
DescEx="<p>Checks state of the lock key specified by <var>KeyCode</var>. Returns True if the lock key is on or False if it is off.</p><p>An exception is raised if <var>KeyCode</var> is not a valid lock key code. Valid lock key codes are <var>VK_CAPITAL</var>, <var>VK_NUMLOCK</var> and <var>VK_SCROLL</var>.</p>"
Units=SysUtils,Windows
SeeAlso=SetLockKeyState
Snip=050.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsRunningOnBattery]
DescEx="<p>Checks if the computer is running on battery power and returns True if so or False when running on mains or if the power status is unknown.</p>"
Extra="<p>Based on code published on the <a href="http://www.delphifaq.com/">Delphi FAQ</a>.</p>"
Units=Windows
SeeAlso=RemainingBatteryPercent
Snip=146.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Pause]
DescEx="Pauses for <var>ADelay</var> milliseconds before returning."
Extra="<p>Performs a busy wait.</p><p>Modifications to handle potential clock roll over and sleeping suggested by Montor.</p>"
Units=Windows
Depends=ProcessMessages
SeeAlso=Delay
Snip=144.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProgramFileName]
DescEx="<p>Returns the executing program's file name.</p>"
Units=SysUtils
Depends=ProgramFileSpec
SeeAlso=ProgramFileSpec,ProgramName,ProgramPath
Snip=105.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProgramFileSpec]
DescEx="<p>Returns the fully specified path and file name of the executing program.</p>"
Extra="<p>Based on code suggested by Alan Bailey.</p>"
SeeAlso=ProgramFileName,ProgramPath,ProgramName
Snip=104.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProgramName]
DescEx="<p>Returns the name of the executing program (i.e. the program file name minus its extension).</p>"
Depends=ProgramFileName,RemoveFileExt
SeeAlso=ProgramFileSpec,ProgramFileName,ProgramPath
Snip=107.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProgramPath]
DescEx="<p>Returns the directory containing the executing program.</p>"
Extra="<p>Based on code suggested by Alan Bailey.</p>"
Units=SysUtils
Depends=ProgramFileSpec
SeeAlso=ProgramFileSpec,ProgramFileName,ProgramName
Snip=106.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RemainingBatteryPercent]
DescEx="<p>Returns remaining battery life as a percentage (0..100), or -1 if the remaining battery life is unknown.</p>"
Extra="<p>Based on code published on the <a href="http://www.delphifaq.com/">Delphi FAQ</a>.</p>"
Units=Windows
SeeAlso=IsRunningOnBattery
Snip=145.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SendKeysToWindow]
DescEx="Sends key strokes to the window with the handle <var>HWnd</var> that correspond to the characters in string <var>Text</var>."
Extra="<p>Based on code suggested by DennisLV.</p>"
Units=Windows,Messages
SeeAlso=EmptyKeyQueue,PostKeyEx32
Snip=121.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SetLockKeyState]
DescEx="<p>Sets the state of the lock key with code <var>KeyCode</var> to the value given by <var>IsOn</var>. Passing True to <var>IsOn</var> switches the lock key on and passing False switches it off.</p><p>An exception is raised if <var>KeyCode</var> is not a valid lock key code. Valid key codes are <var>VK_CAPITAL</var>, <var>VK_NUMLOCK</var> and <var>VK_SCROLL</var>.</p>"
Units=SysUtils,Windows
Depends=IsLockKeyOn
SeeAlso=IsLockKeyOn
Snip=051.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CurrentMemoryUsage]
DescEx="<p>Gets the current application memory usage or 0 on error.</p>"
Extra="<p><strong>Note:</strong> According to <a href="http://msdn.microsoft.com/en-us/library/ms683219.aspx">MSDN</a> this function requires Windows 2000 as a minimum. The <mono>PsAPI</mono> unit loads <var>GetProcessMemoryInfo</var> dynamically so that there is no catastrophic error on earlier OSs: <var>CurrentMemoryUsage</var> will quietly return 0.</p><p>Contributed by EX4.</p>"
SeeAlso=TrimAppMemorySize
Units=SysUtils,Windows,PsAPI
Snip=264.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[DeleteEnvVar]
DescEx="<p>Deletes environment variable <var>VarName</var>.</p><p>Returns 0 on success or the relevant Windows error code on failure.</p>"
Extra="<p><strong>Note:</strong> An environment variable deleted by this function updates only the current process' own environment variables. Changes are lost when the process terminates. Therefore this function cannot be used to delete Windows environment variables.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize
Units=Windows
Snip=595.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommand]
DescEx="<p>Executes the given DOS command line <var>CommandLine</var> using the Windows command line processor.</p><p>Use <var>CmdShow</var> to specifiy whether and how the command window should be displayed by using one of the Windows <var><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms633548">SW_XXX</a></var> constants.</p><p>Pass True to <var>WaitUntilComplete</var> to make the routine halt until the DOS command has completed or pass False to make the routine return immediately the DOS command has started.</p><p>The optional <var>WorkingDir</var> parameter can be used to specify the working directory to be used by the DOS command.</p><p>Returns True if the command is executed or False if not.</p>"
Extra="<p>For example <mono>DOSCommand('COPY D:\Foo.txt D:\Bar.txt', SW_HIDE, True);</mono> causes the given DOS <em>Copy</em> command to be executed in a hidden window and to wait for the command to complete before returning.</p><p>Modified from code contributed by Joe Donth.</p>"
Units=Windows
SeeAlso=DOSCommandRedirect_A,DOSCommandRedirect_B
Snip=613.dat
Delphi5=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommandRedirect_A]
DisplayName="DOSCommandRedirect (TStream overload)"
DescEx="<p>Executes the given DOS command in a hidden window and redirects its output to the given stream.</p><p>Returns True if the command executes or False otherwise.</p>"
Extra="Closely based on code contributed by Joe Donth."
Units=Classes,Windows
SeeAlso=DOSCommand,DOSCommandRedirect_B
Snip=614.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommandRedirect_B]
DisplayName="DOSCommandRedirect (File overload)"
DescEx="<p>Executes the given DOS command in a hidden window and redirects its output to the given file.</p><p>Returns True if the command executes or False otherwise.</p>"
Units=Classes,
Depends=DOSCommandRedirect_A
SeeAlso=DOSCommand,DOSCommandRedirect_A
Snip=615.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetAllEnvVars]
DescEx="<p>Stores all the environment variables in the current process' environment block in the given string list in <mono>Name=Value</mono> format.</p>"
Extra="<p>Often there will be an entry in the environment block not in the form <mono>Name=Value</mono> (it may have format <mono>=Value</mono>). The data can be read from the string list via its <var>Items[]</var> property, but not from the <var>Names[]</var> property.</p>"
SeeAlso=GetEnvVar,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Depends=MultiSzToStrings
Units=Classes,Windows
Snip=596.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetAvailablePhysMemory]
DescEx="<p>Returns the currently available physical memory in bytes.</p><p>Returns <mono>0</mono> on error. Use <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p>"
SeeAlso=GetTotalPhysMemory,GetPercentMemoryUsed
Units=Windows
Snip=630.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetDefaultPrinterName]
DescEx="<p>Returns the name of the default printer or empty string if there is no default printer.</p>"
Units=Printers
Snip=562.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetEnvironmentBlockSize]
DescEx="<p>Returns the size of the current process' environment block, in characters.</p>"
Extra="<p><strong>Note:</strong> This routine returns the number of <em>characters</em> of data in the environment block, <strong>not</strong> the number of <em>bytes</em>. To get the number of bytes in the block, multiply the retuned value by <mono>SizeOf(Char)</mono>.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,SetEnvVarValue,DeleteEnvVar
Units=SysUtils,Windows
Snip=597.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetEnvVar]
DescEx="<p>Returns the value of the given environment variable.</p><p>If the environment variable does not exist then the empty string is returned.</p>"
SeeAlso=GetAllEnvVars,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Units=Windows
Snip=598.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetErrorMessageWithId]
DescEx="<p>Returns an error message string, in the current user's default language, that corresponds to the given OS error code. If the error code is zero, the empty string is returned.</p>"
Extra="<p>This routine is identical to <var>SysUserErrorMessage</var> except when <var>OSErrorCode</var> is 0, when <var>SysUserErrorMessage</var> returns a message and <var>GetLastErrorMessageWithId</var> returns the empty string.</p><p>Derived from code contributed by Johan Keizer.</p>"
Depends=SysUserErrorMessage
SeeAlso=SysUserErrorMessage
Snip=594.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetMacAddress]
DescEx="<p>Returns the MAC address of the first ethernet adapter on the computer or the empty string if there is no adapter or if the function fails.</p>"
Extra="<p><warning>Warning 1</warning>: Does not work on Windows Vista, Windows 2008 Server or later. This code depends on <mono>Netbios</mono> which is not supported on these OSs.</p> <p><warning>Warning 2</warning>: According to MSDN this code may not work reliably on the Windows 9x platform.</p>"
Units=SysUtils,Windows,Nb30
Snip=090.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetPercentMemoryUsed]
DescEx="<p>Returns the approximate percentage of total physical memory that is currently in use.</p><p>Returns <mono>0</mono> on error. Call <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p>"
SeeAlso=GetAvailablePhysMemory,GetTotalPhysMemory
Units=Windows
Snip=631.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetTotalPhysMemory]
DescEx="<p>Returns the total physical memory in bytes.</p><p>Returns <mono>0</mono> on error. Use <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p><p>Contributed by Torsten Hunnenberg.</p>"
SeeAlso=GetAvailablePhysMemory,GetPercentMemoryUsed
Units=Windows
Snip=591.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[IsAppResponding]
DescEx="<p>Checks if the application that owns the window with the given handle is responding (returns True), or hung (returns False).</p>"
Extra="<p>Exceptions are raised if the window handle is not valid or if the required API functions can't be loaded.</p><p>The code uses different User32 functions for Windows 95 and Windows NT - <var>IsHungThread</var> is used on Windows 9x and <var>IsHungAppWindow</var> on Windows NT.</p>"
Units=SysUtils,Windows
Depends=GetWindowThreadID,IsWinNT
Snip=242.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[IsLibraryInstalled]
DescEx="Checks if a library with name <var>LibFileName</var> is installed."
Extra="<strong>Note</strong>: For compilers that don't support <var>SafeLoadLibrary</var>, use <var>Windows.LoadLibrary</var> instead, but note that the FPU control word could be changed and a warning dialog may be displayed if the DLL can't be found."
Units=SysUtils,Windows
Snip=118.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PostKeyEx32]
DescEx="Manufactures a series of key events. <var>Key</var> is the virtual key code of the required key, <var>Shift</var> is a set of shift keys and <var>SpecialKey</var> informs if the key is a special key such as the numeric pad."
Extra="<p>Code by Peter Below, contributed by Bill Miller.</p> <p>The events go to the control that has focus. Note that for characters <var>Key</var> is always the upper-case version of the character. Sending without any modifier keys will result in a lower-case character, sending with <var>[ssShift]</var> will result in an upper-case character.</p>"
Units=Classes,Windows
SeeAlso=SendKeysToWindow
Snip=243.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProcessMessages]
DescEx="<p>Processes all the messages a program's message queue.</p>"
Extra="<p>Can be used as light weight replacement for <var>Application.ProcessMessages</var>.</p><p>Conributed by Joe Donth.</p>"
Units=Windows,Messages
Snip=143.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RefreshEnvironment]
DescEx="<p>Notifies all windows that the system environment variables have been changed.</p>"
Extra="<p>If you modify environment variables in the registry the rest of the system will not notice unless you notify them. Use this routine to do that.</p><p><strong>Note:</strong> You must change environment variables in the registry for the changes to have a global effect - changing your own application's environment won't work.</p>
<p>Contributed by Michael Rockett. Adapted for 64 bit by DelphiDabbler.</p>"
Units=Windows,Messages
Snip=599.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SetEnvVar]
DescEx="<p>Sets the value of environment variable <var>VarName</var> to the value <var>VarValue</var>.</p><p>Returns 0 on success or the relevant Windows error code on failure.</p>"
Extra="<p><strong>Note:</strong> An environment variable created or modified using this method updates only the current process' own environment variables. Changes are lost when the process terminates. Therefore this function cannot be used to modify the Windows environment variables.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Units=Windows
Snip=600.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SetEnvVarValue]
DescEx="<p>Sets the value of environment variable <var>VarName</var> to the value <var>VarValue</var>.</p><p>Returns the empty string on success or the relevant Windows error message on failure.</p>"
Extra="<p>Any error message returned is in the current user's default language.</p><p>Slightly modified from code contributed by Johan Keizer.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,GetEnvironmentBlockSize,DeleteEnvVar
Depends=GetErrorMessageWithId
Units=Windows
Snip=601.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SysUserErrorMessage]
DescEx="<p>Returns an error message string, in the current user's default language, that corresponds to the given OS error code.</p>"
Extra="<p>This routine is identical to <var>GetLastErrorMessageWithId</var> except when <var>OSErrorCode</var> is 0, when <var>SysUserErrorMessage</var> returns a message and <var>GetLastErrorMessageWithId</var> returns the empty string.</p><p>Closely based on code contributed by Johan Keizer.</p>"
SeeAlso=GetErrorMessageWithId
Units=SysUtils,Windows
Snip=593.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TerminateProcessByID]
DescEx="<p>Forcefully terminates the process with the given process ID.</p><p>Returns True on success and False if the process ID is invalid or if the process can't be terminated.</p>"
Extra="<p>Use this routine to terminate a hung application.</p><p>Contributed by Marv.</p>"
Units=SysUtils,Windows
Snip=592.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimAppMemorySize]
DescEx="<p>Trims the application's working set to its minimum size.</p>"
Extra="<p>This routine temporarily trims the application's working set size to zero. This effectively means the process is swapped out of physical RAM.</p><p><strong>Note:</strong> This routine requires the correct privileges to succeed on Windows NT operating systems. See the MSDN documentation for <a href="http://msdn.microsoft.com/en-us/library/ms686234">SetProcessWorkingSetSize</a> for details.</p><p>Slightly modified from code contributed by Shlomo Abuisak.</p>"
SeeAlso=CurrentMemoryUsage
Units=Windows
Snip=301.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
