[DecimalToFraction]
Desc="Converts the given decimal to a fraction. The numerator and denominator are passed out as floating point numbers in FractionNumerator and FractionDenominator respectively. AccuracyFactor determines how accurate the conversion is to be."
DescEx="<p>Converts the given decimal to a fraction. The numerator and denominator are passed out as floating point numbers in <var>FractionNumerator</var> and <var>FractionDenominator</var> respectively.</p><p><var>AccuracyFactor</var> determines how accurate the conversion is to be.</p>"
Extra="<p>Examples of <var>AccuracyFactor</var> values: 0.0005 requires accuracy of 3 decimal places and 0.000005 requires accuracy of 5 decimal places.</p> <p>Adapted from the Turbo Pascal code presented in &quot;<a href="http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF">Algorithm To Convert A Decimal To A Fraction</a>&quot; by John Kennedy, Mathematics Department, Santa Monica College.</p>"
Units=SysUtils,Math
Snip=468.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitSum]
Desc="Returns the sum of the digits from the given integer, using recursion."
Extra="<p>Sums of digits of negative numbers are negative, for example <mono>DigitSum(-42)=-6</mono>.</p><p>Contributed Rubem Nascimento da Rocha.</p>"
TestInfo=advanced
Snip=418.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Float]
DisplayName="DistanceBetweenPoints (TPointF overload)"
Desc="Calculates the distance between two given points with double precision floating point valued coordinates."
Extra="<p>Formula from <a href="http://www.efg2.com/Lab/Library/Delphi/Graphics/Math.htm">EFG's Delphi Graphics: Algorithms</a> page.</p>"
Depends=TPointF
SeeAlso=DistanceBetweenPoints_Int
Units=Math
Snip=495.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Int]
DisplayName="DistanceBetweenPoints (TPoint overload)"
Desc="Calculates the distance between two points with integer valued co-ordinates."
Extra="<p>Formula from <a href="http://www.efg2.com/Lab/Library/Delphi/Graphics/Math.htm">EFG's Delphi Graphics: Algorithms</a> page.</p>"
SeeAlso=DistanceBetweenPoints_Float
Units=Math,Types
Snip=494.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD]
Desc="Determines the greatest common divisor of two given non-zero integers."
Extra="<p>Uses Euclid's method.</p><p>Note that <mono>GCD(a,b) = GCD(|a|,b) = GCD(a,|b|) = GCD(|a|,|b|)</mono>, which implies that <mono>GCD(a,b)</mono> is always positive.</p><p>Modified from Hans van Kruijssen's <a href="http://www.efg2.com/Lab/Library/UseNet/2000/0315b.txt">UseNet Post</a> as referenced on <a href="http://www.efg2.com/Lab/Library/Delphi/Algorithms/index.html">efg's Delphi Reference Library</a>.</p>"
SeeAlso=GCD2,LCD
TestInfo=advanced
Snip=201.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD2]
Desc="Determines the greatest common divisor of two given non-zero integers."
Extra="<p>Uses a recursive implementation of Euclid's method.</p><p>Note that <mono>GCD2(a,b) = GCD2(|a|,b) = GCD2(a,|b|) = GCD2(|a|,|b|)</mono>, which implies that <mono>GCD2(a,b)</mono> is always positive.</p><p>Modified from Hans van Kruijssen's <a href="http://www.efg2.com/Lab/Library/UseNet/2000/0315b.txt">UseNet Post</a> as referenced on <a href="http://www.efg2.com/Lab/Library/Delphi/Algorithms/index.html">efg's Delphi Reference Library</a>.</p>"
SeeAlso=GCD,LCD
TestInfo=advanced
Snip=416.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime]
Desc="Checks if the given number is prime."
Extra="<p>On versions of Delphi that support <var>Int64</var> parameters to the <var>Sqrt</var> function, the type of <var>N</var>, <var>Max</var> &amp; <var>Divisor</var> can be changed to <var>Int64</var>.</p> <p>Adapted from code contributed by Don Rowlett.</p>"
SeeAlso=IsPrime2
TestInfo=advanced
Snip=232.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime2]
Desc="Checks if the given number is prime."
Extra="<p>Uses less code than <var>IsPrime</var> and does not require any floating point operations.</p><p>Contributed by daniel.</p>"
SeeAlso=IsPrime
TestInfo=advanced
Snip=570.dat
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LCD]
Desc="Returns the least common divisor of two given non-zero integers."
Extra="<p>Note that <mono>LCD(a,b) = LCD(|a|,b) = LCD(a,|b|) = LCD(|a|,|b|)</mono>, which implies that <mono>LCD(a,b)</mono> is always positive.</p><p>Modified from Hans van Kruijssen's <a href="http://www.efg2.com/Lab/Library/UseNet/2000/0315b.txt">UseNet Post</a> as referenced on <a href="http://www.efg2.com/Lab/Library/Delphi/Algorithms/index.html">efg's Delphi Reference Library</a>.</p>"
Depends=GCD
SeeAlso=GCD,GCD2
TestInfo=advanced
Snip=467.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Double]
DisplayName="MaxOfArray (Double overload)"
Desc="Returns the maximum value contained in the given array of double precision floating point values. The array must not be empty."
DescEx="<p>Returns the maximum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
Snip=428.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Extended]
DisplayName="MaxOfArray (Extended overload)"
Desc="Returns the maximum value contained in the given array of extended precision floating point values. The array must not be empty."
DescEx="<p>Returns the maximum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Extended,MaxOfArray_Double,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=429.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Int64]
DisplayName="MaxOfArray (Int64 overload)"
Desc="Returns the maximum value contained in the given array of 64 bit integer values. The array must not be empty."
DescEx="<p>Returns the maximum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Int64,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Integer,MaxOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=430.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Integer]
DisplayName="MaxOfArray (Integer overload)"
Desc="Returns the maximum value contained in the given array of integer values. The array must not be empty."
DescEx="<p>Returns the maximum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Integer,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=431.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Single]
DisplayName="MaxOfArray (Single overload)"
Desc="Returns the maximum value contained in the given array of single precision floating point values. The array must not be empty."
DescEx="<p>Returns the maximum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Single,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
Snip=432.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Double]
DisplayName="Mid (Double overload)"
Desc="Returns the middle of three double precision floating point values."
Units=Math
SeeAlso=Mid_Extended,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Double,MinOfArray_Double,MinMidMax_Double
TestInfo=advanced
Snip=423.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Extended]
DisplayName="Mid (Extended overload)"
Desc="Returns the middle of three extended precision floating point values."
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Extended,MinOfArray_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=424.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Int64]
DisplayName="Mid (Int64 overload)"
Desc="Returns the middle of three 64 bit integer values."
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Integer,Mid_Single,MaxOfArray_Int64,MinOfArray_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=425.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Integer]
DisplayName="Mid (Integer overload)"
Desc="Returns the middle of three integer values."
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Single,MaxOfArray_Integer,MinOfArray_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=426.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Single]
DisplayName="Mid (Single overload)"
Desc="Returns the middle of three single precision floating point values."
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Integer,MaxOfArray_Single,MinOfArray_Single,MinMidMax_Single
TestInfo=advanced
Snip=427.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Double]
DisplayName="MinMidMax (Double overload)"
Desc="Finds the minimum, middle and maximum values of three double precision floating point numbers, A, B and C and returns them in Min, Mid and Max respectively."
DescEx="<p>Finds the minimum, middle and maximum values of three double precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Double,MaxOfArray_Double,MinOfArray_Double
Snip=472.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Extended]
DisplayName="MinMidMax (Extended overload)"
Desc="Finds the minimum, middle and maximum values of three extended precision floating point numbers, A, B and C and returns them in Min, Mid and Max respectively."
DescEx="<p>Finds the minimum, middle and maximum values of three extended precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Extended,MaxOfArray_Extended,MinOfArray_Extended
Snip=473.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Int64]
DisplayName="MinMidMax (Int64 overload)"
Desc="Finds the minimum, middle and maximum values of three 64 bit integers, A, B and C and returns them in Min, Mid and Max respectively."
DescEx="<p>Finds the minimum, middle and maximum values of three 64 bit integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Integer,MinMidMax_Single,Mid_Int64,MaxOfArray_Int64,MinOfArray_Int64
Snip=474.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Integer]
DisplayName="MinMidMax (Integer overload)"
Desc="Finds the minimum, middle and maximum values of three integers, A, B and C and returns them in Min, Mid and Max respectively."
DescEx="<p>Finds the minimum, middle and maximum values of three integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Single,Mid_Integer,MaxOfArray_Integer,MinOfArray_Integer
Snip=475.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Single]
DisplayName="MinMidMax (Single overload)"
Desc="Finds the minimum, middle and maximum values of three single precision floating point numbers, A, B and C and returns them in Min, Mid and Max respectively."
DescEx="<p>Finds the minimum, middle and maximum values of three single precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,Mid_Single,MaxOfArray_Single,MinOfArray_Single
Snip=476.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Double]
DisplayName="MinOfArray (Double overload)"
Desc="Returns the minimum value contained in the given array of double precision floating point values. The array must not be empty."
DescEx="<p>Returns the minimum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
Snip=433.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Extended]
DisplayName="MinOfArray (Extended overload)"
Desc="Returns the minimum value contained in the given array of extended precision floating point values. The array must not be empty."
DescEx="<p>Returns the minimum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Extended,MinOfArray_Double,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=434.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Int64]
DisplayName="MinOfArray (Int64 overload)"
Desc="Returns the minimum value contained in the given array of 64 bit integer values. The array must not be empty."
DescEx="<p>Returns the minimum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Int64,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Integer,MinOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=435.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Integer]
DisplayName="MinOfArray (Integer overload)"
Desc="Returns the minimum value contained in the given array of integer values. The array must not be empty."
DescEx="<p>Returns the minimum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Integer,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=436.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Single]
DisplayName="MinOfArray (Single overload)"
Desc="Returns the minimum value contained in the given array of single precision floating point values. The array must not be empty."
DescEx="<p>Returns the minimum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Single,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
Snip=437.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[NormaliseFractionSign]
Desc="Normalises the sign of the fraction with numerator Num and denominator Denom so that Num takes the sign of the fraction and Denom is non-negative."
DescEx="<p>Normalises the sign of the fraction with numerator <var>Num</var> and denominator <var>Denom</var> so that <var>Num</var> takes the sign of the fraction and <var>Denom</var> is non-negative.</p>"
SeeAlso=FractionToStr,FractionToStrEx
Snip=559.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Pow]
Desc="Raises integer value Base to non-negative integer power Exponent and returns the result."
DescEx="<p>Raises integer value <var>Base</var> to non-negative integer power <var>Exponent</var> and returns the result.</p>"
Snip=561.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ResizeRect_A]
DisplayName="ResizeRect (TSize overload)"
Desc="Resizes rectangle R to size NewSize, leaving the top-left position unchanged. Returns the resized rectangle."
DescEx="<p>Resizes rectangle <var>R</var> to size <var>NewSize</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
Depends=ResizeRect_B
SeeAlso=ResizeRect_B,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=420.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ResizeRect_B]
DisplayName="ResizeRect (Longint overload)"
Desc="Resizes rectangle R to the width and height given by NewWidth and NewHeight, leaving the top-left position unchanged. Returns the resized rectangle."
DescEx="<p>Resizes rectangle <var>R</var> to the width and height given by <var>NewWidth</var> and <var>NewHeight</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
SeeAlso=ResizeRect_A,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=419.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseNumberR]
Desc="Reverses the digits of the given integer, which must be non-negative, and returns the resulting value. Uses recursion."
DescEx="<p>Reverses the digits of the given integer, which must be non-negative, and returns the resulting value.</p><p>Uses recursion.</p>"
Extra="<p>Users of Delphi 7 and later can change the parameter and return type to <var>UInt64</var> and remove the assertion.</p><p>Slightly modified from code contributed by Rubem Nascimento da Rocha.</p>"
Units=Math
SeeAlso=ReverseNumber
Snip=406.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SAR]
Desc="Performs an arithmetic right shift operation on the given value and returns the result. Value is shifted right by Shift bits. Shift must be in the range 0..31 and is adjusted if it is not."
DescEx="<p>Performs an arithmetic right shift operation on the given value and returns the result. <var>Value</var> is shifted right by <var>Shift</var> bits.</p><p><var>Shift</var> must be in the range <mono>0..31</mono> and is adjusted if it is not.</p>"
Extra="<p><var>SAR</var> differs from the <strong>shr</strong> operator in that it preserves any sign bit.</p><p>For more information about the different kinds of right shift operator, see this <a href="http://delphidabbler.blogspot.co.uk/2013/02/the-two-faces-of-shr.html">blog post</a>.</p>"
Snip=560.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ScaleRect]
Desc="Scales the given rectangle by the given scale factor and returns the scaled rectangle."
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Types
SeeAlso=ZoomRatio_A,ZoomRatio_B,ZoomRatio_C,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=383.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SimplifyFraction]
Desc="Simplifies the fraction with numerator Num and denominator Denom to its lowest terms. If the fraction is already in its lowest terms then Num and Denom are left unchanged."
DescEx="<p>Simplifies the fraction with numerator <var>Num</var> and denominator <var>Denom</var> to its lowest terms.</p><p>If the fraction is already in its lowest terms then <var>Num</var> and <var>Denom</var> are left unchanged.</p>"
Depends=GCD
SeeAlso=DecimalToFraction,NormaliseFractionSign
Snip=621.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_A]
DisplayName="StretchRect (asymmetric overload)"
Desc="Stretches rectangle R by the given scaling factors and returns the result. The rectangle's width is scaled by ScalingX and its height by ScalingY. The top left corner of the rectangle is not changed."
DescEx="<p>Stretches rectangle <var>R</var> by the given scaling factors and returns the result.</p><p>The rectangle's width is scaled by <var>ScalingX</var> and its height by <var>ScalingY</var>.</p><p>The top left corner of the rectangle is not changed.</p>"
Units=SysUtils,Types
SeeAlso=StretchRect_B,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=421.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_B]
DisplayName="StretchRect (symmetric overload)"
Desc="Stretches the rectangle R by scale factor Scaling and returns the result. Both width and height are stretched by the same scale factor. The top left corner is not changed."
DescEx="<p>Stretches the rectangle <var>R</var> by scale factor <var>Scaling</var> and returns the result. Both width and height are stretched by the same scale factor.</p><p>The top left corner is not changed.</p>"
Units=Types
Depends=StretchRect_A
SeeAlso=StretchRect_A,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=422.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_A]
DisplayName="ZoomRatio (Integer overload)"
Desc="Calculates and returns the largest scaling that can be applied to a rectangle of width SrcWidth and height SrcHeight to fit it, without changing the aspect ratio, within a second rectangle of width DestWidth and height DestHeight."
DescEx="Calculates and returns the largest scaling that can be applied to a rectangle of width <var>SrcWidth</var> and height <var>SrcHeight</var> to fit it, without changing the aspect ratio, within a second rectangle of width <var>DestWidth</var> and height <var>DestHeight</var>."
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Math
SeeAlso=ZoomRatio_B,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=376.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_B]
DisplayName="ZoomRatio (TSize overload)"
Desc="Calculates and returns the largest scaling that can be applied to a rectangle of size SrcSize to fit it, without changing the aspect ratio, within a second rectangle of size DestSize."
DescEx="Calculates and returns the largest scaling that can be applied to a rectangle of size <var>SrcSize</var> to fit it, without changing the aspect ratio, within a second rectangle of size <var>DestSize</var>."
Units=Types
Depends=ZoomRatio_A
SeeAlso=ZoomRatio_A,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=377.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_C]
DisplayName="ZoomRatio (TRect overload)"
Desc="Calculates and returns the laregest scaling that can be applied to rectangle SrcRect to fit it, without changing the aspect ratio, within rectangle DestRect."
DescEx="Calculates and returns the largest scaling that can be applied to rectangle <var>SrcRect</var> to fit it, without changing the aspect ratio, within rectangle <var>DestRect</var>."
Units=Types
Depends=RectSize,ZoomRatio_B
SeeAlso=ZoomRatio_A,ZoomRatio_B,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=378.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
