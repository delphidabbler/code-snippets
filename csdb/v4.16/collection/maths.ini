[AllDigitsDifferent]
Desc="Checks if all the digits of the given integer are different to each other."
Comments="An example of an integer with all digits different is 15862."
SeeAlso=AllDigitsSame
Snip=498.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AllDigitsSame]
Desc="Checks if all the digits of the given integer are the same."
Comments="An example of an integer with all digits the same is 777777."
SeeAlso=AllDigitsDifferent,RepeatedDigits
Snip=499.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitCount]
Desc="Counts the number of digits in the given integer."
Credits="Contributed by Bill Miller."
SeeAlso=DigitCount2,DigitCountR
TestInfo=advanced
Snip=202.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitCount2]
Desc="Counts the number of digits in the given integer."
Credits="Based on code suggested by Don Rowlett."
Units=Math
SeeAlso=DigitCount,DigitCountR
TestInfo=advanced
Snip=204.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitCountR]
Desc="Counts the number of digits in the given integer using recursion."
Credits="Contributed by Rubem Nascimento da Rocha."
SeeAlso=DigitCount,DigitCount2
TestInfo=advanced
Snip=417.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Factorial]
Desc="Calculates the factorial of the given number."
Credits="Adapted from code contributed by Don Rowlett."
Snip=231.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsRectNormal]
DescEx="<p>Checks if the given rectangle is normalized, i.e. <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>.</p>"
Units=Windows
SeeAlso=NormalizeRect
Snip=124.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MoveRectToOrigin]
DescEx="<p>Translates the give rectangle to the origin.</p><p>The top and left co-ordinates are set to zero and the bottom and right co-ordinates are adjusted accordingly.</p>"
Units=Types
Snip=373.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[NormalizeRect]
DescEx="Normalises the given rectangle so that <var>Left</var> &lt;= <var>Right</var> and <var>Top</var> &lt;= <var>Bottom</var>."
Credits="Inspired by code published by Marco Cantu in supplementary chapter 22 of Mastering Delphi 5."
Units=Windows
Depends=ExchangeInt
SeeAlso=IsRectNormal
Snip=125.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectArea]
Desc="Returns the area of the given rectangle."
Commants="Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top."
SeeAlso=RectHeight,RectSize,RectWidth
Units=Windows
Snip=496.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y


[RectHeight]
DescEx="<p>Returns the height of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Comments="Adopts the convention that the rectangle's bottom and right are not included in it, so that height = bottom - top."
Units=Windows
SeeAlso=RectSize,RectWidth,NormalizeRect
Snip=127.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectSize]
DescEx="<p>Returns the size of the given rectangle.</p><p>The returned dimensions are always non-negative even if the rectangle is not normalized.</p>"
Comments="Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left and height = bottom - top."
Units=Windows
Depends=RectWidth,RectHeight
SeeAlso=RectWidth,RectHeight,NormalizeRect
Snip=128.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RectWidth]
DescEx="<p>Returns the width of the given rectangle.</p><p>The return value is always non-negative even if the rectangle is not normalized.</p>"
Comments="Adopts the convention that the rectangle's bottom and right are not included in it, so that width = right - left."
Units=Windows
SeeAlso=RectSize,RectHeight,NormalizeRect
Snip=126.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RepeatedDigits]
Desc="Checks if the given integer contains only a single repeated digit."
Comments="An example of an integer with a single repeated digit is 5555."
Credits="Slightly modified from code contributed by Rubem Rocha."
Units=SysUtils,Math
SeeAlso=AllDigitsSame
Snip=497.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseNumber]
DescEx="<p>Reverses the digits of integer <var>AValue</var> and returns the resulting value.</p><p><var>AValue</var> should be positive: zero is always returned for negative integers.</p>"
Credits="Contributed by Rubem Nascimento da Rocha."
SeeAlso=ReverseNumberR
Snip=405.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SignOfFloat]
Desc="Returns the sign of the given floating point value. Returns -1 if the value is positive, 0 if zero or +1 if negative."
Credits="Contributed by Bill Miller."
SeeAlso=SignOfInt
Snip=205.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SignOfInt]
Desc="Returns the sign of the given integer. Returns -1 if the integer is positive, 0 if zero or +1 if negative."
Credits="Contributed by Bill Miller."
SeeAlso=SignOfFloat
Snip=206.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

# from maths.3.ini

[DecimalToFraction]
DescEx="<p>Converts the given decimal to a fraction. The numerator and denominator are passed out as floating point numbers in <var>FractionNumerator</var> and <var>FractionDenominator</var> respectively.</p><p><var>AccuracyFactor</var> determines how accurate the conversion is to be.</p>"
Extra="<p>Examples of <var>AccuracyFactor</var> values: 0.0005 requires accuracy of 3 decimal places and 0.000005 requires accuracy of 5 decimal places.</p> <p>Adapted from the Turbo Pascal code by John Kennedy, Mathematics Department, Santa Monica College.</p>"
Units=SysUtils,Math
Snip=468.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DigitSum]
Desc="Returns the sum of the digits from the given integer, using recursion."
Extra="<p>Sums of digits of negative numbers are negative, for example <mono>DigitSum(-42)=-6</mono>.</p><p>Contributed Rubem Nascimento da Rocha.</p>"
TestInfo=advanced
Snip=418.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Float]
DisplayName="DistanceBetweenPoints (TPointF overload)"
Desc="Calculates the distance between two given points with double precision floating point valued coordinates."
Depends=TPointF
SeeAlso=DistanceBetweenPoints_Int
Units=Math
Snip=495.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DistanceBetweenPoints_Int]
DisplayName="DistanceBetweenPoints (TPoint overload)"
Desc="Calculates the distance between two points with integer valued co-ordinates."
SeeAlso=DistanceBetweenPoints_Float
Units=Math,Types
Snip=494.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD]
Desc="Determines the greatest common divisor of two given non-zero integers."
Extra="<p>Uses Euclid's method.</p><p>Note that <mono>GCD(a,b) = GCD(|a|,b) = GCD(a,|b|) = GCD(|a|,|b|)</mono>, which implies that <mono>GCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD2,LCD
TestInfo=advanced
Snip=201.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GCD2]
Desc="Determines the greatest common divisor of two given non-zero integers."
Extra="<p>Uses a recursive implementation of Euclid's method.</p><p>Note that <mono>GCD2(a,b) = GCD2(|a|,b) = GCD2(a,|b|) = GCD2(|a|,|b|)</mono>, which implies that <mono>GCD2(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
SeeAlso=GCD,LCD
TestInfo=advanced
Snip=416.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime]
Desc="Checks if the given number is prime."
Extra="<p>On versions of Delphi that support <var>Int64</var> parameters to the <var>Sqrt</var> function, the type of <var>N</var>, <var>Max</var> &amp; <var>Divisor</var> can be changed to <var>Int64</var>.</p> <p>Adapted from code contributed by Don Rowlett.</p>"
SeeAlso=IsPrime2
TestInfo=advanced
Snip=232.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsPrime2]
Desc="Checks if the given number is prime."
Extra="<p>Uses less code than <var>IsPrime</var> and does not require any floating point operations.</p><p>Contributed by daniel.</p>"
SeeAlso=IsPrime
TestInfo=advanced
Snip=570.dat
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[LCD]
Desc="Returns the least common divisor of two given non-zero integers."
Extra="<p>Note that <mono>LCD(a,b) = LCD(|a|,b) = LCD(a,|b|) = LCD(|a|,|b|)</mono>, which implies that <mono>LCD(a,b)</mono> is always positive.</p><p>Modified from code by Hans van Kruijssen.</p>"
Depends=GCD
SeeAlso=GCD,GCD2
TestInfo=advanced
Snip=467.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Double]
DisplayName="MaxOfArray (Double overload)"
DescEx="<p>Returns the maximum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
Snip=428.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Extended]
DisplayName="MaxOfArray (Extended overload)"
DescEx="<p>Returns the maximum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Extended,MaxOfArray_Double,MaxOfArray_Int64,MaxOfArray_Integer,MaxOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=429.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Int64]
DisplayName="MaxOfArray (Int64 overload)"
DescEx="<p>Returns the maximum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Int64,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Integer,MaxOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=430.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Integer]
DisplayName="MaxOfArray (Integer overload)"
DescEx="<p>Returns the maximum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Integer,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=431.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MaxOfArray_Single]
DisplayName="MaxOfArray (Single overload)"
DescEx="<p>Returns the maximum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MinOfArray_Single,MaxOfArray_Double,MaxOfArray_Extended,MaxOfArray_Int64,MaxOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
Snip=432.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Double]
DisplayName="Mid (Double overload)"
Desc="Returns the middle of three double precision floating point values."
Units=Math
SeeAlso=Mid_Extended,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Double,MinOfArray_Double,MinMidMax_Double
TestInfo=advanced
Snip=423.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Extended]
DisplayName="Mid (Extended overload)"
Desc="Returns the middle of three extended precision floating point values."
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Int64,Mid_Integer,Mid_Single,MaxOfArray_Extended,MinOfArray_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=424.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Int64]
DisplayName="Mid (Int64 overload)"
Desc="Returns the middle of three 64 bit integer values."
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Integer,Mid_Single,MaxOfArray_Int64,MinOfArray_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=425.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Integer]
DisplayName="Mid (Integer overload)"
Desc="Returns the middle of three integer values."
Extra="<p>Adapted from code from Bill Miller's snippets collection.</p>"
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Single,MaxOfArray_Integer,MinOfArray_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=426.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Mid_Single]
DisplayName="Mid (Single overload)"
Desc="Returns the middle of three single precision floating point values."
Units=Math
SeeAlso=Mid_Double,Mid_Extended,Mid_Int64,Mid_Integer,MaxOfArray_Single,MinOfArray_Single,MinMidMax_Single
TestInfo=advanced
Snip=427.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Double]
DisplayName="MinMidMax (Double overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three double precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Double,MaxOfArray_Double,MinOfArray_Double
Snip=472.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Extended]
DisplayName="MinMidMax (Extended overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three extended precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Int64,MinMidMax_Integer,MinMidMax_Single,Mid_Extended,MaxOfArray_Extended,MinOfArray_Extended
Snip=473.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Int64]
DisplayName="MinMidMax (Int64 overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three 64 bit integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Integer,MinMidMax_Single,Mid_Int64,MaxOfArray_Int64,MinOfArray_Int64
Snip=474.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Integer]
DisplayName="MinMidMax (Integer overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three integers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Single,Mid_Integer,MaxOfArray_Integer,MinOfArray_Integer
Snip=475.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinMidMax_Single]
DisplayName="MinMidMax (Single overload)"
DescEx="<p>Finds the minimum, middle and maximum values of three single precision floating point numbers, <var>A</var>, <var>B</var> and <var>C</var> and returns them in <var>Min</var>, <var>Mid</var> and <var>Max</var> respectively.</p>"
Extra="<p>Adapted from code contributed by Bruce Wernick.</p>"
SeeAlso=MinMidMax_Double,MinMidMax_Extended,MinMidMax_Int64,MinMidMax_Integer,Mid_Single,MaxOfArray_Single,MinOfArray_Single
Snip=476.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Double]
DisplayName="MinOfArray (Double overload)"
DescEx="<p>Returns the minimum value contained in the given array of double precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Double,MinMidMax_Double
TestInfo=advanced
Snip=433.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Extended]
DisplayName="MinOfArray (Extended overload)"
DescEx="<p>Returns the minimum value contained in the given array of extended precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Extended,MinOfArray_Double,MinOfArray_Int64,MinOfArray_Integer,MinOfArray_Single,Mid_Extended,MinMidMax_Extended
TestInfo=advanced
Snip=434.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Int64]
DisplayName="MinOfArray (Int64 overload)"
DescEx="<p>Returns the minimum value contained in the given array of 64 bit integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Int64,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Integer,MinOfArray_Single,Mid_Int64,MinMidMax_Int64
TestInfo=advanced
Snip=435.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Integer]
DisplayName="MinOfArray (Integer overload)"
DescEx="<p>Returns the minimum value contained in the given array of integer values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Integer,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Single,Mid_Integer,MinMidMax_Integer
TestInfo=advanced
Snip=436.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[MinOfArray_Single]
DisplayName="MinOfArray (Single overload)"
DescEx="<p>Returns the minimum value contained in the given array of single precision floating point values.</p><p>The array must not be empty.</p>"
SeeAlso=MaxOfArray_Single,MinOfArray_Double,MinOfArray_Extended,MinOfArray_Int64,MinOfArray_Integer,Mid_Single,MinMidMax_Single
TestInfo=advanced
Snip=437.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[NormaliseFractionSign]
DescEx="<p>Normalises the sign of the fraction with numerator <var>Num</var> and denominator <var>Denom</var> so that <var>Num</var> takes the sign of the fraction and <var>Denom</var> is non-negative.</p>"
SeeAlso=FractionToStr,FractionToStrEx
Snip=559.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[Pow]
DescEx="<p>Raises integer value <var>Base</var> to non-negative integer power <var>Exponent</var> and returns the result.</p>"
Snip=561.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ResizeRect_A]
DisplayName="ResizeRect (TSize overload)"
DescEx="<p>Resizes rectangle <var>R</var> to size <var>NewSize</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
Depends=ResizeRect_B
SeeAlso=ResizeRect_B,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=420.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ResizeRect_B]
DisplayName="ResizeRect (Longint overload)"
DescEx="<p>Resizes rectangle <var>R</var> to the width and height given by <var>NewWidth</var> and <var>NewHeight</var>, leaving the top-left position unchanged.</p><p>Returns the resized rectangle.</p>"
Units=Types
SeeAlso=ResizeRect_A,StretchRect_A,StretchRect_B,ScaleRect,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=419.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ReverseNumberR]
DescEx="<p>Reverses the digits of the given integer, which must be non-negative, and returns the resulting value.</p><p>Uses recursion.</p>"
Extra="<p>Users of Delphi 7 and later can change the parameter and return type to <var>UInt64</var> and remove the assertion.</p><p>Slightly modified from code contributed by Rubem Nascimento da Rocha.</p>"
Units=Math
SeeAlso=ReverseNumber
Snip=406.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SAR]
DescEx="<p>Performs an arithmetic right shift operation on the given value and returns the result. <var>Value</var> is shifted right by <var>Shift</var> bits.</p><p><var>Shift</var> must be in the range <mono>0..31</mono> and is adjusted if it is not.</p>"
Extra="<p><var>SAR</var> differs from the <strong>shr</strong> operator in that it preserves any sign bit.</p><p>For more information about the different kinds of right shift operator, see this <a href="http://delphidabbler.blogspot.co.uk/2013/02/the-two-faces-of-shr.html">blog post</a>.</p>"
Snip=560.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ScaleRect]
Desc="Scales the given rectangle by the given scale factor and returns the scaled rectangle."
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Types
SeeAlso=ZoomRatio_A,ZoomRatio_B,ZoomRatio_C,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=383.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SimplifyFraction]
DescEx="<p>Simplifies the fraction with numerator <var>Num</var> and denominator <var>Denom</var> to its lowest terms.</p><p>If the fraction is already in its lowest terms then <var>Num</var> and <var>Denom</var> are left unchanged.</p>"
Depends=GCD
SeeAlso=DecimalToFraction,NormaliseFractionSign
Snip=621.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_A]
DisplayName="StretchRect (asymmetric overload)"
DescEx="<p>Stretches rectangle <var>R</var> by the given scaling factors and returns the result.</p><p>The rectangle's width is scaled by <var>ScalingX</var> and its height by <var>ScalingY</var>.</p><p>The top left corner of the rectangle is not changed.</p>"
Units=SysUtils,Types
SeeAlso=StretchRect_B,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=421.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[StretchRect_B]
DisplayName="StretchRect (symmetric overload)"
DescEx="<p>Stretches the rectangle <var>R</var> by scale factor <var>Scaling</var> and returns the result. Both width and height are stretched by the same scale factor.</p><p>The top left corner is not changed.</p>"
Units=Types
Depends=StretchRect_A
SeeAlso=StretchRect_A,ScaleRect,ResizeRect_A,ResizeRect_B,ZoomRatio_A,ZoomRatio_B,ZoomRatio_C
TestInfo=advanced
Snip=422.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_A]
DisplayName="ZoomRatio (Integer overload)"
DescEx="Calculates and returns the largest scaling that can be applied to a rectangle of width <var>SrcWidth</var> and height <var>SrcHeight</var> to fit it, without changing the aspect ratio, within a second rectangle of width <var>DestWidth</var> and height <var>DestHeight</var>."
Extra="<p>Slightly modified from code contributed by Montor.</p>"
Units=Math
SeeAlso=ZoomRatio_B,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=376.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_B]
DisplayName="ZoomRatio (TSize overload)"
DescEx="Calculates and returns the largest scaling that can be applied to a rectangle of size <var>SrcSize</var> to fit it, without changing the aspect ratio, within a second rectangle of size <var>DestSize</var>."
Units=Types
Depends=ZoomRatio_A
SeeAlso=ZoomRatio_A,ZoomRatio_C,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=377.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ZoomRatio_C]
DisplayName="ZoomRatio (TRect overload)"
DescEx="Calculates and returns the largest scaling that can be applied to rectangle <var>SrcRect</var> to fit it, without changing the aspect ratio, within rectangle <var>DestRect</var>."
Units=Types
Depends=RectSize,ZoomRatio_B
SeeAlso=ZoomRatio_A,ZoomRatio_B,ScaleRect,StretchRect_A,StretchRect_B,ResizeRect_A,ResizeRect_B
Snip=378.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
