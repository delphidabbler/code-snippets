[AddDefThousandSeparator]
Desc="Adds the thousands separator for the current locale at the correct location(s) in string S and returns the result. S is assumed to be the string representation of a positive whole number."
DescEx="<p>Adds the thousands separator for the current locale at the correct location(s) in string <var>S</var> and returns the result.</p><p><var>S</var> is assumed to be the string representation of a positive whole number.</p>"
Extra="<p>Users of Delphi XE &amp; later or Free Pascal 2.6.0 &amp; later should use <var>AddDefThousandSeparatorXE</var> instead of this routine.</p>"
Units=SysUtils
Depends=AddThousandSeparator
SeeAlso=AddThousandSeparator,AddDefThousandSeparatorXE
Snip=163.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=N
DelphiXE4=N
DelphiXE5=N
DelphiXE6=N
DelphiXE7=N
DelphiXE8=N
Delphi10S=N
FPC=Y

[AddDefThousandSeparatorXE]
Desc="Adds the thousands separator for the current locale at the correct location(s) in string S and returns the result. S is assumed to be the string representation of a positive whole number."
DescEx="<p>Adds the thousands separator for the current locale at the correct location(s) in string <var>S</var> and returns the result.</p><p><var>S</var> is assumed to be the string representation of a positive whole number.</p>"
Extra="<p>This is a version of <var>AddDefThousandSeparator</var> suitable for use with Delphi XE &amp; later or Free Pascal 2.6.0 &amp; later. For Delphi 2010 and earlier, use <var>AddDefThousandSeparator</var> instead.</p>"
Units=SysUtils
Depends=AddThousandSeparator
SeeAlso=AddThousandSeparator,AddDefThousandSeparator
Snip=555.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=N
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=N
Delphi2010=N
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[AnsiStringToCharSet]
Desc="Creates and returns a set of all the unique characters from the given ANSI string."
Extra="<p><warning>Note:</warning> This function works <strong>does not</strong> work with multi-byte ANSI strings: it assumes a character occupies exactly one byte.</p>"
Depends=RawByteString,TCharSet
Snip=363.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CEscapeStr]
Desc="Returns a copy of string S which has each character appearing in EscapableChars replaced by an escape sequence comprising the character '\' followed by the corresponding character from EscapeChars."
DescEx="<p>Returns a copy of string <var>S</var> which has each character appearing in <var>EscapableChars</var> replaced by an escape sequence comprising the character <mono>'\'</mono> followed by the matching character from <var>EscapeChars</var>.</p>"
Extra="<p>Note that <var>EscapeChars</var> and <var>EscapableChars</var> must be the same length and <var>EscapeChars[X]</var> should be the escaped equivalent of <var>EscapableChars[X]</var>. For example, if you wish to escape <mono>CR</mono>, <mono>LF</mono>, <mono>TAB</mono> and <mono>\</mono> to <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> respectively, set <var>EscapableChars</var> to <mono>#13#10#9'\'</mono> and <var>EscapeChars</var> to <mono>'rnt\'</mono>.</p>"
Units=SysUtils
SeeAlso=CUnEscapeStr
Snip=102.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ChangeChar]
Desc="Replaces all occurrences the character ASearch in AString with the AReplace character, and returns the resulting string."
DescEx="Replaces all occurrences the character <var>ASearch</var> in <var>AString</var> with the <var>AReplace</var> character, and returns the resulting string."
Extra="<p><warning>Warning:</warning> This routine replaces code points rather than characters. It is <strong>not safe</strong> for use with ANSI multi-byte character sets or, on Unicode versions of Delphi, with characters outside the Unicode <a href="http://en.wikipedia.org/wiki/Mapping_of_Unicode_character_planes">basic multilingual plane</a>.</p><p>Contributed by Bill Miller.</p>"
Snip=349.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CompareNumberStr]
Desc="Compares two strings, S1 and S2, treating any whole, non-negative, numbers embedded in the strings as numbers rather than text. Text comparisons are case sensitive. Returns a negative value if S1 < S2, a positve value if S1 > S2 or 0 if S1 and S2 are equal."
DescEx="<p>Compares two strings, <var>S1</var> and <var>S2</var>, treating any whole, non-negative, numbers embedded in the strings as numbers rather than text. Text comparisons are case sensitive.</p><p>Returns a negative value if <var>S1</var> &lt; <var>S2</var>, a positve value if <var>S1</var> &gt; <var>S2</var> or 0 if <var>S1</var> and <var>S2</var> are equal.</p>"
Extra="<p><strong>Note 1:</strong> this routine is not safe for use with multi-byte character sets (ANSI strings) or with strings containing characters outside the Basic Multilingual Plane (Unicode strings).</p><p><strong>Note 2:</strong> the routine does not recognise the <mono>+</mono> and <mono>-</mono> unary operators so performs a string comparison on them. This means that, for example, <mono>'+12'</mono> will appear to be less than <mono>'-12'</mono>, because the string <mono>'+'</mono> is less than <mono>'-'</mono>.</p>"
Units=SysUtils
Depends=IsASCIIDigit
Snip=611.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CompressWhiteSpace]
Desc="Returns a copy of the given string where each sequence of one or more white space characters is replaced by a single space character."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
Depends=IsWhiteSpace
SeeAlso=ContainsWhiteSpace,IsWhiteSpace,StripWhiteSpace
Snip=035.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ContainsWhiteSpace]
Desc="Checks if the given string contains any white space."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Depends=ContainsDelims
SeeAlso=ContainsDelims,CompressWhiteSpace,IsWhiteSpace,StripWhiteSpace
Snip=239.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CountWords]
Desc="Returns the number of white space delimited words in the given string."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=Classes
Depends=ExplodeWords
SeeAlso=CountUnquotedWords,WordCount
Snip=182.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CUnEscapeStr]
Desc="Returns a copy of string S where each C-style escape sequence, introduced by '\' and followed by a character from EscapeChars, is replaced by the corresponding character from EscapableChars. If an unrecognised escape character is found it is copied literally, stripped of its preceeding '\'."
DescEx="<p>Returns a copy of string <var>S</var> where each C-style escape sequence, introduced by <mono>'\'</mono> and followed by a character from <var>EscapeChars</var>, is replaced by the corresponding character from <var>EscapableChars</var>.</p><p>If an unrecognised escape character is found it is copied literally, stripped of its preceeding <mono>'\'</mono>.</p>"
Extra="<p>Note that <var>EscapeChars</var> and <var>EscapableChars</var> must be the same length and <var>EscapeChars[X]</var> should be the escaped equivalent of <var>EscapableChars[X]</var>. For example, if you wish to unescape <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> as <mono>CR</mono>, <mono>LF</mono>, <mono>TAB</mono> and <mono>\</mono> set <var>EscapeChars</var> to <mono>'rnt\'</mono> and <var>EscapableChars</var> to <mono>#13#10#9'\'</mono>.</p>"
Units=SysUtils
SeeAlso=CEscapeStr,IsValidCEscapedStr
Snip=103.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[CutWordByIndex]
Desc="Deletes the Nth word from string Str and returns the deleted word. Words are delimited by any of the characters in Delims. If there is no Nth word then the empty string is returned and Str is not modified."
DescEx="<p>Deletes the <var>N</var>th word from string <var>Str</var> and returns the deleted word. Words are delimited by any of the characters in <var>Delims</var>.</p><p>If there is no <var>N</var>th word then the empty string is returned and <var>Str</var> is not modified.</p>"
Extra="<p>Slightly modified from code contributed by Bill Miller.</p>"
Depends=GetStartAndEndWord,TCharSet
SeeAlso=DeleteWordByIndex,GetWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=304.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DeleteWordByIndex]
Desc="Deletes and discards the Nth word from string Str. Words are delimited by any of the characters in Delims. Returns True if the Nth word was found and deleted from Str or False if there is no Nth word and Str is unchanged."
DescEx="<p>Deletes and discards the <var>N</var>th word from string <var>Str</var>. Words are delimited by any of the characters in <var>Delims</var>.</p><p>Returns True if the <var>N</var>th word was found and deleted from <var>Str</var> or False if there is no <var>N</var>th word and <var>Str</var> is unchanged.</p>"
Depends=GetStartAndEndWord
SeeAlso=CutWordByIndex,GetWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=305.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeStr]
Desc="Splits the string S into segments separated by delimiter Delim and stores each segment in turn in string-list List, replacing any existing content. If Trim is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if AllowEmpty is False. The number of segments added to List is returned."
DescEx="<p>Splits the string <var>S</var> into segments separated by delimiter <var>Delim</var> and stores each segment in turn in string-list <var>List</var>, replacing any existing content.</p><p>If <var>Trim</var> is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if <var>AllowEmpty</var> is False.</p><p>The number of segments added to <var>List</var> is returned.</p>"
Extra="<p>If <var>AllowEmpty</var> is False and <var>Trim</var> is True then empty strings and those made up of only white space are ignored.</p>"
Units=Classes
Depends=SplitStr
SeeAlso=ExplodeStrArray,JoinStr,JoinStrArray,SplitStr,TrimStringList,ExplodeWords,ParseStr,SplitString
Snip=034.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeStrArray]
Desc="Splits the string S into segments separated by delimiter Delim and returns a string array containing the segments. If Trim is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if AllowEmpty is False."
DescEx="<p>Splits the string <var>S</var> into segments separated by delimiter <var>Delim</var> and returns a string array containing the segments.</p><p>If <var>Trim</var> is True segments are trimmed of leading and trailing spaces. Empty segments (after any trimming) are discarded if <var>AllowEmpty</var> is False.</p>"
Extra="<p>If <var>AllowEmpty</var> is False and <var>Trim</var> is True then empty strings and those made up of only white space are ignored.</p>"
Units=Classes,Types
Depends=ExplodeStr,StringListToArray
SeeAlso=ExplodeStr,JoinStr,JoinStrArray,SplitStr,TrimStringList,ExplodeWords
Snip=348.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ExplodeWords]
Desc="Extracts a list of white space delimited words from string S and returns the number of words found. The extracted words are stored in stringlist Words, overwriting any existing content."
DescEx="Extracts a list of white space delimited words from string <var>S</var> and returns the number of words found. The extracted words are stored in stringlist <var>Words</var>, overwriting any existing content."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=Classes
Depends=ExplodeStr,CompressWhiteSpace
SeeAlso=ExplodeStr,ExplodeUnquotedWords
Snip=180.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetFirstWord]
Desc="Returns the first word of string S where words are delimited by the character supplied in Delim. If Delim is the space character (the default) then any sequence of white space will act as the word delimiter."
DescEx="<p>Returns the first word of string <var>S</var> where words are delimited by the character supplied in <var>Delim</var>.</p><p>If <var>Delim</var> is the <em>space</em> character (the default) then any sequence of white space will act as the word delimiter.</p>"
Extra="<p><warning>Warning:</warning> If you want to use white space as the word delimiter always specify the <em>space</em> character as the value of <var>Delim</var>. Any other white space character (as defined below) will not work as a delimiter.</p><p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p><p>Slightly modified from code contributed by Bill Miller.</p>"
Units=Classes
Depends=CompressWhiteSpace,ExplodeStr
SeeAlso=GetLastWord
Snip=192.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetLastWord]
Desc="Returns the last word of string S where words are delimited by the character supplied in Delim. If Delim is the space character (the default) then any sequence of white space will act as the word delimiter."
DescEx="<p>Returns the last word of string <var>S</var> where words are delimited by the character supplied in <var>Delim</var>.</p><p>If <var>Delim</var> is the <em>space</em> character (the default) then any sequence of white space will act as the word delimiter.</p>"
Extra="<p><warning>Warning:</warning> If you want to use white space as the word delimiter always specify the <em>space</em> character as the value of <var>Delim</var>. Any other white space character (as defined below) will not work as a delimiter.</p><p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p><p>Slightly modified from code contributed by Bill Miller.</p>"
Units=Classes
Depends=CompressWhiteSpace,ExplodeStr
SeeAlso=GetFirstWord
Snip=193.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetStartAndEndWord]
Desc="Finds the location of the Nth word in string Str and passes the start and end of the location out in StartIdx and EndIdx. Words are delimited by the any of the characters in Delim. Returns True if the Nth word was found or False, with StartIdx set to 0, if not."
DescEx="<p>Finds the location of the <var>N</var>th word in string <var>Str</var> and passes the start and end of the location out in <var>StartIdx</var> and <var>EndIdx</var>. Words are delimited by the any of the characters in <var>Delim</var>.</p><p>Returns True if the <var>N</var>th word was found or False, with <var>StartIdx</var> set to 0, if not.</p>"
Extra="<p>Modified from code contributed by Bill Miller.</p>"
Units=SysUtils
Depends=IsCharInSet,TCharSet
Snip=303.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetWordByIndex]
Desc="Locates and returns the Nth word from string Str. Words are delimited by the any of the characters in Delim. If there is no Nth word then the empty string is returned."
DescEx="<p>Locates and returns the <var>N</var>th word from string <var>Str</var>. Words are delimited by the any of the characters in <var>Delim</var>.</p><p>If there is no Nth word then the empty string is returned.</p>"
Depends=GetStartAndEndWord,TCharSet
SeeAlso=CutWordByIndex,DeleteWordByIndex,PosByIndex,ReplaceWordByIndex
Snip=306.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[InString]
Desc="Checks if string Needle is contained in Haystack and returns True if so or False if not. Checking is case insensitive if IgnoreCase is True."
DescEx="<p>Checks if string <var>Needle</var> is contained in <var>Haystack</var> and returns True if so or False if not.</p><p>Checking is case insensitive if <var>IgnoreCase</var> is True.</p>"
Extra="<p>Contributed by Alan Bailey.</p>"
Units=SysUtils
Snip=612.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsHexStr]
Desc="Checks if the given string contains only valid hex digits. Returns True if so or False otherwise."
Units=SysUtils
Depends=IsCharInSet
Snip=100.3.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsNumeric]
Units=SysUtils
Desc="Checks if the string Value contains a valid numeric value and returns True if so or False if not. If AllowFloat is true then Value may contain a floating point number, otherwise it must be an integer. If TrimWhiteSpace is True any white space surrounding Value is trimmed before testing."
DescEx="<p>Checks if the string <var>Value</var> contains a valid numeric value and returns True if so or False if not.</p><p>If <var>AllowFloat</var> is true then <var>Value</var> may contain a floating point number, otherwise it must be an integer. If <var>TrimWhiteSpace</var> is True any white space surrounding <var>Value</var> is trimmed before testing.</p>"
Extra="<p>Floating point numbers can be in normal or scientific notation.</p><p>Integers can be expressed as decimal or hexadecimal numbers, with hex numbers prefixed by either <mono>'$'</mono> or <mono>'0x'</mono>.</p>"
TestInfo=advanced
Snip=132.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=N
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsValidCEscapedStr]
Desc="Checks if any C-style escape characters in string S match those given by ValidEscChars. Returns True if so and False if not."
DescEx="<p>Checks if any C-style escape characters in string <var>S</var> match those given by <var>ValidEscChars</var>.</p><p>Returns True if so and False if not.</p>"
Extra="<p><strong>Note 1:</strong> A &quot;C-style&quot; escape character begins with a <mono>\</mono> character.</p><p><strong>Note 2:</strong> This function does not support escape sequences longer than one character: e.g. it supports <mono>\n</mono> but not <mono>\045</mono>.</p><p><strong>Example:</strong> To check that a string contains only the escape sequences <mono>\r</mono>, <mono>\n</mono>, <mono>\t</mono> and <mono>\\</mono> set <var>ValidEscChars</var> to <mono>'rnt\'</mono>.</p>"
Units=SysUtils
SeeAlso=CEscapeStr,CUnEscapeStr
Snip=101.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[IsWhiteSpace]
Desc="Checks if the given character is white space."
Extra="<p><strong>Note:</strong> This function treats only the <em>space</em>, <mono>TAB</mono>, <mono>LF</mono>, <mono>VT</mono>, <mono>FF</mono> and <mono>CR</mono> characters as white space.</p>"
Units=SysUtils
SeeAlso=CompressWhiteSpace,ContainsWhiteSpace,StripWhiteSpace
Depends=IsCharInSet
Snip=133.3.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
