[CurrentMemoryUsage]
Desc="Gets the current application memory usage or 0 on error."
Extra="<p><strong>Note:</strong> According to <a href="http://msdn.microsoft.com/en-us/library/ms683219.aspx">MSDN</a> this function requires Windows 2000 as a minimum. The <mono>PsAPI</mono> unit loads <var>GetProcessMemoryInfo</var> dynamically so that there is no catastrophic error on earlier OSs: <var>CurrentMemoryUsage</var> will quietly return 0.</p><p>Contributed by EX4.</p>"
SeeAlso=TrimAppMemorySize
Units=SysUtils,Windows,PsAPI
Snip=264.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[DeleteEnvVar]
Desc="Deletes environment variable VarName. Returns 0 on success or the relevant Windows error code on failure."
DescEx="<p>Deletes environment variable <var>VarName</var>.</p><p>Returns 0 on success or the relevant Windows error code on failure.</p>"
Extra="<p>Taken from the article &quot;<a href="http://www.delphidabbler.com/articles?article=6#deleteenvvar">How to access environment variables</a>&quot; on DelphiDabbler.com.</p><p><strong>Note:</strong> An environment variable deleted by this function updates only the current process' own environment variables. Changes are lost when the process terminates. Therefore this function cannot be used to delete Windows environment variables.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize
Units=Windows
Snip=595.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommand]
Desc="Executes the given DOS command line CommandLine using the Windows command line processor. Use CmdShow to specifiy whether and how the command window should be displayed by using one of the Windows SW_XXX constants. Pass True to WaitUntilComplete to make the routine halt until the DOS command has completed or pass False to make the routine return immediately the DOS command has started. The optional WorkingDir parameter can be used to specify the working directory to be used by the DOS command. Returns True if the command is executed or False if not."
DescEx="<p>Executes the given DOS command line <var>CommandLine</var> using the Windows command line processor.</p><p>Use <var>CmdShow</var> to specifiy whether and how the command window should be displayed by using one of the Windows <var><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms633548">SW_XXX</a></var> constants.</p><p>Pass True to <var>WaitUntilComplete</var> to make the routine halt until the DOS command has completed or pass False to make the routine return immediately the DOS command has started.</p><p>The optional <var>WorkingDir</var> parameter can be used to specify the working directory to be used by the DOS command.</p><p>Returns True if the command is executed or False if not.</p>"
Extra="<p>For example <mono>DOSCommand('COPY D:\Foo.txt D:\Bar.txt', SW_HIDE, True);</mono> causes the given DOS <em>Copy</em> command to be executed in a hidden window and to wait for the command to complete before returning.</p><p>Modified from code contributed by Joe Donth.</p>"
Units=Windows
SeeAlso=DOSCommandRedirect_A,DOSCommandRedirect_B
Snip=613.dat
Delphi5=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommandRedirect_A]
DisplayName="DOSCommandRedirect (TStream overload)"
Desc="Executes the given DOS command in a hidden window and redirects its output to the given stream. Returns True if the command executes or False otherwise."
DescEx="<p>Executes the given DOS command in a hidden window and redirects its output to the given stream.</p><p>Returns True if the command executes or False otherwise.</p>"
Extra="Closely based on code contributed by Joe Donth."
Units=Classes,Windows
SeeAlso=DOSCommand,DOSCommandRedirect_B
Snip=614.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[DOSCommandRedirect_B]
DisplayName="DOSCommandRedirect (File overload)"
Desc="Executes the given DOS command in a hidden window and redirects its output to the given file. Returns True if the command executes or False otherwise."
DescEx="<p>Executes the given DOS command in a hidden window and redirects its output to the given file.</p><p>Returns True if the command executes or False otherwise.</p>"
Units=Classes,
Depends=DOSCommandRedirect_A
SeeAlso=DOSCommand,DOSCommandRedirect_A
Snip=615.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetAllEnvVars]
Desc="Stores all the environment variables in the current process' environment block in the given string list in Name=Value format."
DescEx="<p>Stores all the environment variables in the current process' environment block in the given string list in <mono>Name=Value</mono> format.</p>"
Extra="<p>Often there will be an entry in the environment block not in the form <mono>Name=Value</mono> (it may have format <mono>=Value</mono>). The data can be read from the string list via its <var>Items[]</var> property, but not from the <var>Names[]</var> property.</p><p>Adapted from the article &quot;<a href="http://www.delphidabbler.com/articles?article=6#getallenvvars">How to access environment variables</a>&quot; on DelphiDabbler.com.</p>"
SeeAlso=GetEnvVar,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Depends=MultiSzToStrings
Units=Classes,Windows
Snip=596.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetAvailablePhysMemory]
Desc="Returns the currently available physical memory in bytes. Returns 0 on error. Use GetLastError to get the error code."
DescEx="<p>Returns the currently available physical memory in bytes.</p><p>Returns <mono>0</mono> on error. Use <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p>"
SeeAlso=GetTotalPhysMemory,GetPercentMemoryUsed
Units=Windows
Snip=630.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetDefaultPrinterName]
Desc="Returns the name of the default printer or empty string if there is no default printer."
Units=Printers
Snip=562.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetEnvironmentBlockSize]
Desc="Returns the size of the current process' environment block, in characters."
Extra="<p><strong>Note:</strong> This routine returns the number of <em>characters</em> of data in the environment block, <strong>not</strong> the number of <em>bytes</em>. To get the number of bytes in the block, multiply the retuned value by <mono>SizeOf(Char)</mono>.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,SetEnvVarValue,DeleteEnvVar
Units=SysUtils,Windows
Snip=597.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetEnvVar]
Desc="Returns the value of the given environment variable. If the environment variable does not exist then the empty string is returned."
DescEx="<p>Returns the value of the given environment variable.</p><p>If the environment variable does not exist then the empty string is returned.</p>"
Extra="<p>Taken from the article &quot;<a href="http://www.delphidabbler.com/articles?article=6#getenvvarvalue">How to access environment variables</a>&quot; on DelphiDabbler.com.</p>"
SeeAlso=GetAllEnvVars,SetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Units=Windows
Snip=598.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetErrorMessageWithId]
Desc="Returns an error message string, in the current user's default language, that corresponds to the given OS error code. If the error code is zero, the empty string is returned."
Extra="<p>This routine is identical to <var>SysUserErrorMessage</var> except when <var>OSErrorCode</var> is 0, when <var>SysUserErrorMessage</var> returns a message and <var>GetLastErrorMessageWithId</var> returns the empty string.</p><p>Derived from code contributed by Johan Keizer.</p>"
Depends=SysUserErrorMessage
SeeAlso=SysUserErrorMessage
Snip=594.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[GetMacAddress]
Desc="Returns the MAC address of the first ethernet adapter on the computer or the empty string if there is no adapter or if the function fails."
Extra="<p>Based on code at MSDN knowledge base article <a href="http://support.microsoft.com/kb/q118623/">Q118623</a>.</p> <p><warning>Warning 1</warning>: Does not work on Windows Vista, Windows 2008 Server or later. This code depends on <mono>Netbios</mono> which is not supported on these OSs.</p> <p><warning>Warning 2</warning>: According to MSDN this code may not work reliably on the Windows 9x platform.</p>"
Units=SysUtils,Windows,Nb30
Snip=090.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetPercentMemoryUsed]
Desc="Returns the approximate percentage of total physical memory that is currently in use. Returns 0 on error. Call GetLastError to get the error code."
DescEx="<p>Returns the approximate percentage of total physical memory that is currently in use.</p><p>Returns <mono>0</mono> on error. Call <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p>"
SeeAlso=GetAvailablePhysMemory,GetTotalPhysMemory
Units=Windows
Snip=631.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[GetTotalPhysMemory]
Desc="Returns the total physical memory in bytes. Returns 0 on error. Use GetLastError to get the error code."
DescEx="<p>Returns the total physical memory in bytes.</p><p>Returns <mono>0</mono> on error. Use <var>GetLastError</var> to get the error code.</p>"
Extra="<p>This routine requires Windows XP or Windows 2003 Server or later.</p><p>Contributed by Torsten Hunnenberg.</p>"
SeeAlso=GetAvailablePhysMemory,GetPercentMemoryUsed
Units=Windows
Snip=591.dat
Delphi7=N
Delphi2005Win32=N
Delphi2006Win32=N
Delphi2007=N
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[IsAppResponding]
Desc="Checks if the application that owns the window with the given handle is responding (returns True), or hung (returns False)."
Extra="<p>Exceptions are raised if the window handle is not valid or if the required API functions can't be loaded.</p><p>The code uses different User32 functions for Windows 95 and Windows NT - <var>IsHungThread</var> is used on Windows 9x and <var>IsHungAppWindow</var> on Windows NT.</p>"
Units=SysUtils,Windows
Depends=GetWindowThreadID,IsWinNT
Snip=242.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=N

[IsLibraryInstalled]
Desc="Checks if a library with name LibFileName is installed."
DescEx="Checks if a library with name <var>LibFileName</var> is installed."
Extra="<strong>Note</strong>: For compilers that don't support <var>SafeLoadLibrary</var>, use <var>Windows.LoadLibrary</var> instead, but note that the FPU control word could be changed and a warning dialog may be displayed if the DLL can't be found."
Units=SysUtils,Windows
Snip=118.dat
Delphi2=N
Delphi3=N
Delphi4=N
Delphi5=Q
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[PostKeyEx32]
Desc="Manufactures a series of key events. Key is the virtual key code of the required key, Shift is a set of shift keys and SpecialKey informs if the key is a special key such as the numeric pad."
DescEx="Manufactures a series of key events. <var>Key</var> is the virtual key code of the required key, <var>Shift</var> is a set of shift keys and <var>SpecialKey</var> informs if the key is a special key such as the numeric pad."
Extra="<p>Code by Peter Below, contributed by Bill Miller.</p> <p>The events go to the control that has focus. Note that for characters <var>Key</var> is always the upper-case version of the character. Sending without any modifier keys will result in a lower-case character, sending with <var>[ssShift]</var> will result in an upper-case character.</p>"
Units=Classes,Windows
SeeAlso=SendKeysToWindow
Snip=243.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[ProcessMessages]
Desc="Processes all the messages a program's message queue."
Extra="<p>Can be used as light weight replacement for <var>Application.ProcessMessages</var>.</p><p>Conributed by Joe Donth.</p>"
Units=Windows,Messages
Snip=143.dat
Delphi2=Y
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[RefreshEnvironment]
Desc="Notifies all windows that the system environment variables have been changed."
Extra="<p>If you modify environment variables in the registry the rest of the system will not notice unless you notify them. Use this routine to do that. See Microsoft's article &quot;<a href="http://support.microsoft.com/kb/104011">How to propagate environment variables to the system</a>&quot; for more information.</p><p><strong>Note:</strong> You must change environment variables in the registry for the changes to have a global effect - changing your own application's environment won't work.</p>
<p>Contributed by Michael Rockett. Adapted for 64 bit by DelphiDabbler.</p>"
Units=Windows,Messages
Snip=599.dat
Delphi2=N
Delphi3=N
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SetEnvVar]
Desc="Sets the value of environment variable VarName to the value VarValue. Returns 0 on success or the relevant Windows error code on failure."
DescEx="<p>Sets the value of environment variable <var>VarName</var> to the value <var>VarValue</var>.</p><p>Returns 0 on success or the relevant Windows error code on failure.</p>"
Extra="<p>Taken from the article &quot;<a href="http://www.delphidabbler.com/articles?article=6#setenvvarvalue">How to access environment variables</a>&quot; on DelphiDabbler.com.</p><p><strong>Note:</strong> An environment variable created or modified using this method updates only the current process' own environment variables. Changes are lost when the process terminates. Therefore this function cannot be used to modify the Windows environment variables.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVarValue,GetEnvironmentBlockSize,DeleteEnvVar
Units=Windows
Snip=600.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SetEnvVarValue]
Desc="Sets the value of environment variable VarName to the value VarValue. Returns the empty string on success or the relevant Windows error message on failure."
DescEx="<p>Sets the value of environment variable <var>VarName</var> to the value <var>VarValue</var>.</p><p>Returns the empty string on success or the relevant Windows error message on failure.</p>"
Extra="<p>Any error message returned is in the current user's default language.</p><p>Slightly modified from code contributed by Johan Keizer.</p>"
SeeAlso=GetAllEnvVars,GetEnvVar,SetEnvVar,GetEnvironmentBlockSize,DeleteEnvVar
Depends=GetErrorMessageWithId
Units=Windows
Snip=601.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[SysUserErrorMessage]
Desc="Returns an error message string, in the current user's default language, that corresponds to the given OS error code."
Extra="<p>This routine is identical to <var>GetLastErrorMessageWithId</var> except when <var>OSErrorCode</var> is 0, when <var>SysUserErrorMessage</var> returns a message and <var>GetLastErrorMessageWithId</var> returns the empty string.</p><p>Closely based on code contributed by Johan Keizer.</p>"
SeeAlso=GetErrorMessageWithId
Units=SysUtils,Windows
Snip=593.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TerminateProcessByID]
Desc="Forcefully terminates the process with the given process ID. Returns True on success and False if the process ID is invalid or if the process can't be terminated."
DescEx="<p>Forcefully terminates the process with the given process ID.</p><p>Returns True on success and False if the process ID is invalid or if the process can't be terminated.</p>"
Extra="<p>Use this routine to terminate a hung application.</p><p>Contributed by Marv.</p>"
Units=SysUtils,Windows
Snip=592.dat
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y

[TrimAppMemorySize]
Desc="Trims the application's working set to its minimum size."
Extra="<p>This routine temporarily trims the application's working set size to zero. This effectively means the process is swapped out of physical RAM.</p><p><strong>Note:</strong> This routine requires the correct privileges to succeed on Windows NT operating systems. See the MSDN documentation for <a href="http://msdn.microsoft.com/en-us/library/ms686234">SetProcessWorkingSetSize</a> for details.</p><p>Slightly modified from code contributed by Shlomo Abuisak.</p>"
SeeAlso=CurrentMemoryUsage
Units=Windows
Snip=301.dat
Delphi2=N
Delphi3=Y
Delphi4=Y
Delphi5=Y
Delphi6=Y
Delphi7=Y
Delphi2005Win32=Y
Delphi2006Win32=Y
Delphi2007=Y
Delphi2009Win32=Y
Delphi2010=Y
DelphiXE=Y
DelphiXE2=Y
DelphiXE3=Y
DelphiXE4=Y
Delphi10S=Y
FPC=Y
