{
 * This unit was generated automatically. It incorporates a selection of source
 * code taken from the Code Snippets Database at
 * https://github.com/delphidabbler/code-snippets.
 * 
 * The unit is copyright © 2005-2024 by Peter Johnson & Contributors and is
 * licensed under the MIT License (https://opensource.org/licenses/MIT).
 * 
 * Generated on : Thu, 09 Jan 2025 10:55:06 GMT.
 * Generated by : DelphiDabbler CodeSnip Release 4.24.0.
 * 
 * The latest version of CodeSnip is available from the CodeSnip GitHub project
 * at https://github.com/delphidabbler/codesnip.
}

unit UMathsCatSnippets;

interface

uses
  SysUtils, Math, Types, Windows;

{
  Encapsulates a point with double precision floating point coordinates.
}
type
  TPointF = record
    X, Y: Double;  // x and y coordinates
  end;

{
  Checks if all the digits of the given integer are different to each other.
}
function AllDigitsDifferent(N: Int64): Boolean;

{
  Checks if all the digits of the given integer are the same.
}
function AllDigitsSame(N: Int64): Boolean;

{
  Returns the arithmetic mean of an array of Cardinal values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Cardinal): Double; overload;

{
  Returns the arithmetic mean of an array of Double values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Double): Double; overload;

{
  Returns the arithmetic mean of an array of Integer values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Integer): Double; overload;

{
  Returns the sum of all Cardinal elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Cardinal): Cardinal; overload;

{
  Returns the sum of all Double floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Double): Double; overload;

{
  Returns the sum of all Extended floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Extended): Extended; overload;

{
  Returns the sum of all Int64 elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Int64): Int64; overload;

{
  Returns the sum of all Integer elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Integer): Integer; overload;

{
  Returns the sum of all Single floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Single): Single; overload;

{
  Returns the sum of all UInt64 elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of UInt64): UInt64; overload;

{
  Converts the given decimal to a fraction. The numerator and denominator are
  passed out as floating point numbers in FractionNumerator and
  FractionDenominator respectively.
  AccuracyFactor determines how accurate the conversion is to be.
}
procedure DecimalToFraction(Decimal: Extended; out FractionNumerator: Extended;
  out FractionDenominator: Extended; const AccuracyFactor: Extended);

{
  Counts the number of digits in the given integer.
}
function DigitCount(AInteger: Int64): Integer;

{
  Counts the number of digits in the given integer.
}
function DigitCount2(const AValue: Int64): Integer;

{
  Returns the number of digits in integer N when expressed in base Base.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitCountBase(N: Int64; const Base: Byte): Cardinal;

{
  Counts the number of digits in the given integer using recursion.
}
function DigitCountR(AValue: Int64): Integer;

{
  Calculates the sum of all the digits of integer N in base Base where each
  digit is raised to the power Exponent. The returned value has the same sign as
  N.
  If the result is too large to be represented as an Int64 value then an
  EOverflow exception is raised.
  Bases up to 255 are supported. If Base <= 2 then an EArgumentException
  exception is raised.
}
function DigitPowerSum(N: Integer; const Base: Byte; const Exponent: Byte):
  Int64;

{
  Returns an array containing the digits of integer N when expressed in base
  Base. The array is ordered with the least significant digit first.
  The returned array contains the decimal value of the digit, for e.g. the hex
  symbol F is represented by an array element containing the value 15.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitsOf(N: Int64; const Base: Byte): SysUtils.TBytes;

{
  Returns the sum of the digits from the given integer, using recursion.
}
function DigitSum(AValue: Int64): Integer;

{
  Calculates the sum of all the digits of integer N when epxressed in base Base.
  The returned value has the same sign as N.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitSumBase(N: Int64; const Base: Byte): Integer;

{
  Calculates the distance between two given points with double precision
  floating point valued coordinates.
}
function DistanceBetweenPoints(const P1, P2: TPointF): Extended; overload;

{
  Calculates the distance between two points with integer valued co-ordinates.
}
function DistanceBetweenPoints(const P1, P2: Types.TPoint): Extended; overload;

{
  Calculates the factorial of the given number.
}
function Factorial(N: Byte): Int64;

{
  Determines the greatest common divisor of two given non-zero integers.
}
function GCD(A, B: Integer): Integer;

{
  Determines the greatest common divisor of two given non-zero integers.
}
function GCD2(const A, B: Integer): Integer;

{
  Checks if the given number is prime.
}
function IsPrime(N: Integer): Boolean;

{
  Checks if the given number is prime.
}
function IsPrime2(Val: Integer): Boolean;

{
  Checks if the given rectangle is normalized, i.e. Left <= Right and Top <=
  Bottom.
}
function IsRectNormal(const R: Windows.TRect): Boolean;

{
  Returns the least common divisor of two given non-zero integers.
}
function LCD(A, B: Integer): Integer;

{
  Returns the maximum value contained in the given array of double precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Double): Double; overload;

{
  Returns the maximum value contained in the given array of extended precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Extended): Extended; overload;

{
  Returns the maximum value contained in the given array of 64 bit integer
  values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Int64): Int64; overload;

{
  Returns the maximum value contained in the given array of integer values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Integer): Integer; overload;

{
  Returns the maximum value contained in the given array of single precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Single): Single; overload;

{
  Returns the middle of three double precision floating point values.
}
function Mid(const A, B, C: Double): Double; overload;

{
  Returns the middle of three extended precision floating point values.
}
function Mid(const A, B, C: Extended): Extended; overload;

{
  Returns the middle of three 64 bit integer values.
}
function Mid(const A, B, C: Int64): Int64; overload;

{
  Returns the middle of three integer values.
}
function Mid(const A, B, C: Integer): Integer; overload;

{
  Returns the middle of three single precision floating point values.
}
function Mid(const A, B, C: Single): Single; overload;

{
  Finds the minimum, middle and maximum values of three double precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Double; out Min, Mid, Max: Double); overload;

{
  Finds the minimum, middle and maximum values of three extended precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Extended; out Min, Mid, Max: Extended); 
  overload;

{
  Finds the minimum, middle and maximum values of three 64 bit integers, A, B
  and C and returns them in Min, Mid and Max respectively.
}
procedure MinMidMax(const A, B, C: Int64; out Min, Mid, Max: Int64); overload;

{
  Finds the minimum, middle and maximum values of three integers, A, B and C and
  returns them in Min, Mid and Max respectively.
}
procedure MinMidMax(const A, B, C: Integer; out Min, Mid, Max: Integer);
  overload;

{
  Finds the minimum, middle and maximum values of three single precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Single; out Min, Mid, Max: Single); overload;

{
  Returns the minimum value contained in the given array of double precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Double): Double; overload;

{
  Returns the minimum value contained in the given array of extended precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Extended): Extended; overload;

{
  Returns the minimum value contained in the given array of 64 bit integer
  values.
  The array must not be empty.
}
function MinOfArray(const A: array of Int64): Int64; overload;

{
  Returns the minimum value contained in the given array of integer values.
  The array must not be empty.
}
function MinOfArray(const A: array of Integer): Integer; overload;

{
  Returns the minimum value contained in the given array of single precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Single): Single; overload;

{
  Translates the give rectangle to the origin.
  The top and left co-ordinates are set to zero and the bottom and right
  co-ordinates are adjusted accordingly.
}
function MoveRectToOrigin(const R: Types.TRect): Types.TRect;

{
  Normalises the sign of the fraction with numerator Num and denominator Denom
  so that Num takes the sign of the fraction and Denom is non-negative.
}
procedure NormaliseFractionSign(var Num, Denom: Integer);

{
  Normalises the given rectangle so that Left <= Right and Top <= Bottom.
}
function NormalizeRect(const R: Windows.TRect): Windows.TRect;

{
  Raises integer value Base to non-negative integer power Exponent and returns
  the result.
}
function Pow(const Base: Int64; const Exponent: Byte): Int64;

{
  IEEE compliant function that raises real number X to the power N.
}
function PowN(const X: Extended; const N: Integer): Extended;

{
  Raises integer X to non-negative integer power N.
  If the result is too large to be represented as an Int64 value then an
  EOverflow exception is raised.
}
function PowNZN(const X: Integer; const N: Cardinal): Int64;

{
  Raises integer X to integer power N.
}
function PowNZZ(const X: Integer; const N: Integer): Extended;

{
  Returns the area of the given rectangle.
}
function RectArea(const R: Windows.TRect): Int64;

{
  Returns the height of the given rectangle.
  The return value is always non-negative even if the rectangle is not
  normalized.
}
function RectHeight(const R: Windows.TRect): Integer;

{
  Returns the size of the given rectangle.
  The returned dimensions are always non-negative even if the rectangle is not
  normalized.
}
function RectSize(const R: Windows.TRect): Windows.TSize;

{
  Returns the width of the given rectangle.
  The return value is always non-negative even if the rectangle is not
  normalized.
}
function RectWidth(const R: Windows.TRect): Integer;

{
  Checks if the given integer contains only a single repeated digit.
}
function RepeatedDigits(N: Int64): Boolean;

{
  Resizes rectangle R to size NewSize, leaving the top-left position unchanged.
  Returns the resized rectangle.
}
function ResizeRect(const R: Types.TRect; const NewSize: Types.TSize):
  Types.TRect; overload;

{
  Resizes rectangle R to the width and height given by NewWidth and NewHeight,
  leaving the top-left position unchanged.
  Returns the resized rectangle.
}
function ResizeRect(const R: Types.TRect; const NewWidth, NewHeight: LongInt):
  Types.TRect; overload;

{
  Reverses the digits of integer AValue and returns the resulting value.
  AValue should be positive: zero is always returned for negative integers.
}
function ReverseNumber(AValue: Int64): Int64;

{
  Reverses the digits of the given integer, which must be non-negative, and
  returns the resulting value.
  Uses recursion.
}
function ReverseNumberR(AValue: Int64): Int64;

{
  Performs an arithmetic right shift operation on the given value and returns
  the result. Value is shifted right by Shift bits.
  Shift must be in the range 0..31 and is adjusted if it is not.
}
function SAR(Value: LongInt; Shift: Byte): LongInt;

{
  Scales the given rectangle by the given scale factor and returns the scaled
  rectangle.
}
function ScaleRect(const ARect: Types.TRect; AScaling: Double): Types.TRect;

{
  Returns the sign of the given floating point value. Returns -1 if the value is
  positive, 0 if zero or +1 if negative.
}
function SignOfFloat(const Value: Extended): Integer;

{
  Returns the sign of the given integer. Returns -1 if the integer is positive,
  0 if zero or +1 if negative.
}
function SignOfInt(const Value: Int64): Integer;

{
  Simplifies the fraction with numerator Num and denominator Denom to its lowest
  terms.
  If the fraction is already in its lowest terms then Num and Denom are left
  unchanged.
}
procedure SimplifyFraction(var Num, Denom: Int64);

{
  Stretches rectangle R by the given scaling factors and returns the result.
  The rectangle's width is scaled by ScalingX and its height by ScalingY.
  The top left corner of the rectangle is not changed.
}
function StretchRect(const R: Types.TRect; const ScalingX, ScalingY: Double):
  Types.TRect; overload;

{
  Stretches the rectangle R by scale factor Scaling and returns the result. Both
  width and height are stretched by the same scale factor.
  The top left corner is not changed.
}
function StretchRect(const R: Types.TRect; const Scaling: Double):
  Types.TRect; overload;

{
  Returns the sum of the natural logarithms of each Cardinal element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Cardinal): Extended; overload;

{
  Returns the sum of the natural logarithms of each Double floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Double): Double; overload;

{
  Returns the sum of the natural logarithms of each Extended floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Extended): Extended; overload;

{
  Returns the sum of the natural logarithms of each Int64 element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Int64): Extended; overload;

{
  Returns the sum of the natural logarithms of each Integer element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Integer): Extended; overload;

{
  Returns the sum of the natural logarithms of each Single floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Single): Single; overload;

{
  Returns the sum of the natural logarithms of each UInt64 element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of UInt64): Extended; overload;

{
  Calculates and returns the weighted average of the Cardinal elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Cardinal;
  const Weights: array of Double): Double; overload;

{
  Calculates and returns the weighted average of the Double elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;

{
  Calculates and returns the weighted average of the Integer elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Integer;
  const Weights: array of Double): Double; overload;

{
  Calculates and returns the largest scaling that can be applied to a rectangle
  of width SrcWidth and height SrcHeight to fit it, without changing the aspect
  ratio, within a second rectangle of width DestWidth and height DestHeight.
}
function ZoomRatio(const DestWidth, DestHeight, SrcWidth, SrcHeight: Integer):
  Double; overload;

{
  Calculates and returns the largest scaling that can be applied to a rectangle
  of size SrcSize to fit it, without changing the aspect ratio, within a second
  rectangle of size DestSize.
}
function ZoomRatio(const DestSize, SrcSize: Types.TSize): Double; overload;

{
  Calculates and returns the largest scaling that can be applied to rectangle
  SrcRect to fit it, without changing the aspect ratio, within rectangle
  DestRect.
}
function ZoomRatio(const DestRect, SrcRect: Types.TRect): Double; overload;

implementation

procedure ExchangeInt(var I1, I2: Integer);
  forward;

{
  Checks if all the digits of the given integer are different to each other.
}
function AllDigitsDifferent(N: Int64): Boolean;
var
  UsedDigits: array[0..9] of Boolean; // records which digits have been used
  I: 0..9;  // loops through elements of UsedDigits
  M: 0..9;  // modulus after dividing by 10
begin
  N := Abs(N);
  Result := False;
  for I := 0 to 9 do
    UsedDigits[I] := False;
  while N > 0 do
  begin
    M := N mod 10;
    if UsedDigits[M] then
      Exit;
    UsedDigits[M] := True;
    N := N div 10;
  end;
  Result := True; // if we get here all digits are unique
end;

{
  Checks if all the digits of the given integer are the same.
}
function AllDigitsSame(N: Int64): Boolean;
var
  D: 0..9;  // sample digit from N
begin
  N := Abs(N);
  D := N mod 10;
  Result := False;
  while N > 0 do
  begin
    if N mod 10 <> D then
      Exit;
    N := N div 10;
  end;
  Result := True;
end;

{
  Returns the arithmetic mean of an array of Cardinal values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Cardinal): Double; overload;
var
  X: Cardinal;
begin
  if Length(A) = 0 then
    raise SysUtils.EArgumentException.Create(
      'ArithMean: array is empty'
    );
  Result := 0.0;
  for X in A do
    Result := Result + X / Length(A);
end;

{
  Returns the arithmetic mean of an array of Double values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Double): Double; overload;
var
  X: Double;
begin
  if Length(A) = 0 then
    raise SysUtils.EArgumentException.Create(
      'ArithMean: array is empty'
    );
  Result := 0.0;
  for X in A do
    Result := Result + X / Length(A);
end;

{
  Returns the arithmetic mean of an array of Integer values.
  EArgumentException is raised if the array is empty.
}
function ArithMean(const A: array of Integer): Double; overload;
var
  X: Integer;
begin
  if Length(A) = 0 then
    raise SysUtils.EArgumentException.Create(
      'ArithMean: array is empty'
    );
  Result := 0.0;
  for X in A do
    Result := Result + X / Length(A);
end;

{
  Returns the sum of all Cardinal elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Cardinal): Cardinal; overload;
var
  Elem: Cardinal;
begin
  Result := 0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all Double floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Double): Double; overload;
var
  Elem: Double;
begin
  Result := 0.0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all Extended floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Extended): Extended; overload;
var
  Elem: Extended;
begin
  Result := 0.0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all Int64 elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Int64): Int64; overload;
var
  Elem: Int64;
begin
  Result := 0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all Integer elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of Integer): Integer; overload;
var
  Elem: Integer;
begin
  Result := 0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all Single floating point elements of array A.
  0.0 is returned if the array is empty.
}
function ArraySum(const A: array of Single): Single; overload;
var
  Elem: Single;
begin
  Result := 0.0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Returns the sum of all UInt64 elements of array A.
  0 is returned if the array is empty.
}
function ArraySum(const A: array of UInt64): UInt64; overload;
var
  Elem: UInt64;
begin
  Result := 0;
  for Elem in A do
    Result := Result + Elem;
end;

{
  Converts the given decimal to a fraction. The numerator and denominator are
  passed out as floating point numbers in FractionNumerator and
  FractionDenominator respectively.
  AccuracyFactor determines how accurate the conversion is to be.
}
procedure DecimalToFraction(Decimal: Extended; out FractionNumerator: Extended;
  out FractionDenominator: Extended; const AccuracyFactor: Extended);
var
  DecimalSign: Extended;
  Z: Extended;
  PreviousDenominator: Extended;
  ScratchValue: Extended;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sTooSmall = 'Decimal too small to convert to fraction';
  sTooLarge = 'Decimal too large to convert to fraction';
const
  LargestDecimal: Extended = 1.0E+19;
  SmallestDecimal: Extended = 1.0E-19;
begin
  if Decimal < 0.0 then
    DecimalSign := -1.0
  else
    DecimalSign := 1.0;
  Decimal := Abs(Decimal);
  if Math.SameValue(Decimal, Int(Decimal)) then
  begin
    FractionNumerator := Decimal * DecimalSign;
    FractionDenominator := 1.0;
    Exit;
  end;
  if (Decimal < SmallestDecimal) then // X = 0 already taken care of
    raise SysUtils.EConvertError.Create(sTooSmall);
  if (Decimal > LargestDecimal) then
    raise SysUtils.EConvertError.Create(sTooLarge);
  Z := Decimal;
  PreviousDenominator := 0.0;
  FractionDenominator := 1.0;
  repeat
    Z := 1.0 / (Z - Int(Z));
    ScratchValue := FractionDenominator;
    FractionDenominator := FractionDenominator * Int(Z) + PreviousDenominator;
    PreviousDenominator := ScratchValue;
    FractionNumerator := Int(Decimal * FractionDenominator + 0.5) // Rounding
  until
    (
      Abs(
        Decimal - (FractionNumerator / FractionDenominator)
      ) < AccuracyFactor
    )
    or (Z = Int(Z));
  FractionNumerator := DecimalSign * FractionNumerator;
end;

{
  Counts the number of digits in the given integer.
}
function DigitCount(AInteger: Int64): Integer;
begin
  if AInteger <> 0 then
  begin
    Result := 0;
    AInteger := Abs(AInteger);
    while AInteger > 0 do
    begin
      AInteger := AInteger div 10;
      Inc(Result);
    end;
  end
  else
    Result := 1;
end;

{
  Counts the number of digits in the given integer.
}
function DigitCount2(const AValue: Int64): Integer;
begin
  if AValue <> 0 then
    Result := Math.Floor(Math.Log10(Abs(AValue))) + 1
  else
    Result := 1;
end;

{
  Returns the number of digits in integer N when expressed in base Base.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitCountBase(N: Int64; const Base: Byte): Cardinal;
begin
  if Base < 2 then
    raise SysUtils.EArgumentException.Create(
      'Base must be in the range 2..255'
    );
  if N = 0 then
    Exit(1);
  N := Abs(N);
  Result := 0;
  repeat
    Inc(Result);
    N := N div Base;
  until N = 0;
end;

{
  Counts the number of digits in the given integer using recursion.
}
function DigitCountR(AValue: Int64): Integer;
begin
  if AValue mod 10 = AValue then
    Result := 1
  else
    Result := 1 + DigitCountR(AValue div 10)
end;

{
  Calculates the sum of all the digits of integer N in base Base where each
  digit is raised to the power Exponent. The returned value has the same sign as
  N.
  If the result is too large to be represented as an Int64 value then an
  EOverflow exception is raised.
  Bases up to 255 are supported. If Base <= 2 then an EArgumentException
  exception is raised.
}
function DigitPowerSum(N: Integer; const Base: Byte; const Exponent: Byte):
  Int64;
var
  SignOfN: Math.TValueSign;
  Digit: Integer;
  PowerDigit: Int64;
begin
  if Base < 2 then
    raise SysUtils.EArgumentException.Create(
      'Base must be in the range 2..255'
    );
  if N = 0 then
    Exit(0);
  SignOfN := Math.Sign(N);
  N := Abs(N);
  Result := 0;
  repeat
    Digit := N mod Base;
    PowerDigit := PowNZN(Digit, Exponent);
    if High(Int64) - PowerDigit < Abs(Result) then
      raise SysUtils.EOverflow.Create('Overflow calculating digit power sum');
    Result := Result + PowerDigit;
    N := N div Base;
  until N = 0;
  if SignOfN = Math.NegativeValue then
    Result := -1 * Result;
end;

{
  Returns an array containing the digits of integer N when expressed in base
  Base. The array is ordered with the least significant digit first.
  The returned array contains the decimal value of the digit, for e.g. the hex
  symbol F is represented by an array element containing the value 15.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitsOf(N: Int64; const Base: Byte): SysUtils.TBytes;
var
  Idx: Integer;
begin
  if Base < 2 then
    raise SysUtils.EArgumentException.Create(
      'Base must be in the range 2..255'
    );
  N := Abs(N);
  SetLength(Result, DigitCountBase(N, Base));
  if N > 0 then
  begin
    Idx := 0;
    repeat
      Result[Idx] := N mod Base;
      Inc(Idx);
      N := N div Base;
    until N = 0;
  end
  else
    Result[0] := 0;
end;

{
  Returns the sum of the digits from the given integer, using recursion.
}
function DigitSum(AValue: Int64): Integer;
begin
  if AValue mod 10 = AValue then
    Result := AValue
  else
    Result := (AValue mod 10) + DigitSum(AValue div 10)
end;

{
  Calculates the sum of all the digits of integer N when epxressed in base Base.
  The returned value has the same sign as N.
  Bases up to 255 are supported. If Base < 2 then an EArgumentException
  exception is raised.
}
function DigitSumBase(N: Int64; const Base: Byte): Integer;
var
  SignOfN: Math.TValueSign;
begin
  if Base < 2 then
    raise SysUtils.EArgumentException.Create(
      'Base must be in the range 2..255'
    );
  if N = 0 then
    Exit(0);    
  SignOfN := Math.Sign(N);
  N := Abs(N);
  Result := 0;
  repeat
    Inc(Result, N mod Base);
    N := N div Base;
  until N = 0;
  if SignOfN = Math.NegativeValue then
    Result := -1 * Result;
end;

{
  Calculates the distance between two given points with double precision
  floating point valued coordinates.
}
function DistanceBetweenPoints(const P1, P2: TPointF): Extended; overload;
begin
  Result := Math.Hypot(P1.X - P2.X, P1.Y - P2.Y);
end;

{
  Calculates the distance between two points with integer valued co-ordinates.
}
function DistanceBetweenPoints(const P1, P2: Types.TPoint): Extended; overload;
begin
  Result := Math.Hypot(P1.X - P2.X, P1.Y - P2.Y);
end;

{
  Exchanges the values of two given integers.
}
procedure ExchangeInt(var I1, I2: Integer);
var
  Temp: Integer;  // temporary value used when exchanging values
begin
  Temp := I1;
  I1 := I2;
  I2 := Temp;
end;

{
  Calculates the factorial of the given number.
}
function Factorial(N: Byte): Int64;
var
  K: Integer; // loop control
begin
  Result := 1;
  if (N = 0) or (N = 1) then
    Exit;
  for K := 2 to N do
    Result := Result * K;
end;

{
  Determines the greatest common divisor of two given non-zero integers.
}
function GCD(A, B: Integer): Integer;
var
  Temp: Integer; // used in swapping A & B
begin
  while B <> 0 do
  begin
    Temp := B;
    B := A mod Temp;
    A := Temp;
  end;
  Result := Abs(A);
end;

{
  Determines the greatest common divisor of two given non-zero integers.
}
function GCD2(const A, B: Integer): Integer;
begin
  if B = 0 then
    Result := Abs(A)
  else
    Result := GCD2(B, A mod B);
end;

{
  Checks if the given number is prime.
}
function IsPrime(N: Integer): Boolean;
var
  Max: Integer;     // max divisor
  Divisor: Integer; // different divisors to try
begin
  Result := False;
  if N < 2 then
    Exit; // not a prime
  Result := True;
  if N = 2 then
    Exit; // 2 is prime
  if N mod 2 = 0 then
    Result := False; // even numbers > 2 are not prime
  Max := Trunc(Sqrt(N)) + 1;
  Divisor := 3;
  // test odd numbers
  while (Max > Divisor) and Result do
  begin
    if (N mod Divisor) = 0 then
      Result := False;
    Inc(Divisor, 2); // next odd number
  end;
end;

{
  Checks if the given number is prime.
}
function IsPrime2(Val: Integer): Boolean;
var
  X: Integer; // index
begin
  Result := (Val > 1);
  if Result then
  begin
    for X := (Val div 2) downto 2 do
    begin
      Result := Result and ((Val mod X) <> 0);
      if not Result then
    	Break;
    end;
  end;
end;

{
  Checks if the given rectangle is normalized, i.e. Left <= Right and Top <=
  Bottom.
}
function IsRectNormal(const R: Windows.TRect): Boolean;
begin
  Result := (R.Left <= R.Right) and (R.Top <= R.Bottom);
end;

{
  Returns the least common divisor of two given non-zero integers.
}
function LCD(A, B: Integer): Integer;
begin
  Result := Abs((A * B)) div GCD(A, B);
end;

{
  Returns the maximum value contained in the given array of double precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Double): Double; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] > Result then
      Result := A[Idx];
end;

{
  Returns the maximum value contained in the given array of extended precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Extended): Extended; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] > Result then
      Result := A[Idx];
end;

{
  Returns the maximum value contained in the given array of 64 bit integer
  values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Int64): Int64; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] > Result then
      Result := A[Idx];
end;

{
  Returns the maximum value contained in the given array of integer values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Integer): Integer; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] > Result then
      Result := A[Idx];
end;

{
  Returns the maximum value contained in the given array of single precision
  floating point values.
  The array must not be empty.
}
function MaxOfArray(const A: array of Single): Single; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] > Result then
      Result := A[Idx];
end;

{
  Returns the middle of three double precision floating point values.
}
function Mid(const A, B, C: Double): Double; overload;
begin
  Result := Math.Min(
    Math.Min(
      Math.Max(A, B), Math.Max(B, C)
    ),
    Math.Max(A, C)
  );
end;

{
  Returns the middle of three extended precision floating point values.
}
function Mid(const A, B, C: Extended): Extended; overload;
begin
  Result := Math.Min(
    Math.Min(
      Math.Max(A, B), Math.Max(B, C)
    ),
    Math.Max(A, C)
  );
end;

{
  Returns the middle of three 64 bit integer values.
}
function Mid(const A, B, C: Int64): Int64; overload;
begin
  Result := Math.Min(
    Math.Min(
      Math.Max(A, B), Math.Max(B, C)
    ),
    Math.Max(A, C)
  );
end;

{
  Returns the middle of three integer values.
}
function Mid(const A, B, C: Integer): Integer; overload;
begin
  Result := Math.Min(
    Math.Min(
      Math.Max(A, B), Math.Max(B, C)
    ),
    Math.Max(A, C)
  );
end;

{
  Returns the middle of three single precision floating point values.
}
function Mid(const A, B, C: Single): Single; overload;
begin
  Result := Math.Min(
    Math.Min(
      Math.Max(A, B), Math.Max(B, C)
    ),
    Math.Max(A, C)
  );
end;

{
  Finds the minimum, middle and maximum values of three double precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Double; out Min, Mid, Max: Double); overload;
var
  Temp: Double;
begin
  if A > B then
  begin
    Max := A;
    Min := B;
  end
  else
  begin
    Max := B;
    Min := A;
  end;
  if C > Max then
  begin
    Mid := Max;
    Max := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end
  else
  begin
    Mid := Min;
    Min := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end;
end;

{
  Finds the minimum, middle and maximum values of three extended precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Extended; out Min, Mid, Max: Extended); 
  overload;
var
  Temp: Extended;
begin
  if A > B then
  begin
    Max := A;
    Min := B;
  end
  else
  begin
    Max := B;
    Min := A;
  end;
  if C > Max then
  begin
    Mid := Max;
    Max := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end
  else
  begin
    Mid := Min;
    Min := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end;
end;

{
  Finds the minimum, middle and maximum values of three 64 bit integers, A, B
  and C and returns them in Min, Mid and Max respectively.
}
procedure MinMidMax(const A, B, C: Int64; out Min, Mid, Max: Int64); overload;
var
  Temp: Int64;
begin
  if A > B then
  begin
    Max := A;
    Min := B;
  end
  else
  begin
    Max := B;
    Min := A;
  end;
  if C > Max then
  begin
    Mid := Max;
    Max := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end
  else
  begin
    Mid := Min;
    Min := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end;
end;

{
  Finds the minimum, middle and maximum values of three integers, A, B and C and
  returns them in Min, Mid and Max respectively.
}
procedure MinMidMax(const A, B, C: Integer; out Min, Mid, Max: Integer);
  overload;
var
  Temp: Integer;
begin
  if A > B then
  begin
    Max := A;
    Min := B;
  end
  else
  begin
    Max := B;
    Min := A;
  end;
  if C > Max then
  begin
    Mid := Max;
    Max := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end
  else
  begin
    Mid := Min;
    Min := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end;
end;

{
  Finds the minimum, middle and maximum values of three single precision
  floating point numbers, A, B and C and returns them in Min, Mid and Max
  respectively.
}
procedure MinMidMax(const A, B, C: Single; out Min, Mid, Max: Single); overload;
var
  Temp: Single;
begin
  if A > B then
  begin
    Max := A;
    Min := B;
  end
  else
  begin
    Max := B;
    Min := A;
  end;
  if C > Max then
  begin
    Mid := Max;
    Max := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end
  else
  begin
    Mid := Min;
    Min := C;
    if Mid < Min then
    begin
      Temp := Mid;
      Mid := Min;
      Min := Temp;
    end;
  end;
end;

{
  Returns the minimum value contained in the given array of double precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Double): Double; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] < Result then
      Result := A[Idx];
end;

{
  Returns the minimum value contained in the given array of extended precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Extended): Extended; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] < Result then
      Result := A[Idx];
end;

{
  Returns the minimum value contained in the given array of 64 bit integer
  values.
  The array must not be empty.
}
function MinOfArray(const A: array of Int64): Int64; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] < Result then
      Result := A[Idx];
end;

{
  Returns the minimum value contained in the given array of integer values.
  The array must not be empty.
}
function MinOfArray(const A: array of Integer): Integer; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] < Result then
      Result := A[Idx];
end;

{
  Returns the minimum value contained in the given array of single precision
  floating point values.
  The array must not be empty.
}
function MinOfArray(const A: array of Single): Single; overload;
var
  Idx: Integer;
begin
  Assert(Length(A) > 0);
  Result := A[Low(A)];
  for Idx := Succ(Low(A)) to High(A) do
    if A[Idx] < Result then
      Result := A[Idx];
end;

{
  Translates the give rectangle to the origin.
  The top and left co-ordinates are set to zero and the bottom and right
  co-ordinates are adjusted accordingly.
}
function MoveRectToOrigin(const R: Types.TRect): Types.TRect;
begin
  Result := R;
  Types.OffsetRect(Result, -R.Left, -R.Top);
end;

{
  Normalises the sign of the fraction with numerator Num and denominator Denom
  so that Num takes the sign of the fraction and Denom is non-negative.
}
procedure NormaliseFractionSign(var Num, Denom: Integer);
begin
  if Denom < 0 then
  begin
    Num := -Num;
    Denom := -Denom;
  end;
end;

{
  Normalises the given rectangle so that Left <= Right and Top <= Bottom.
}
function NormalizeRect(const R: Windows.TRect): Windows.TRect;
begin
  Result := R;
  if Result.Left > Result.Right then
    ExchangeInt(Result.Left, Result.Right);
  if Result.Top > Result.Bottom then
    ExchangeInt(Result.Top, Result.Bottom);
end;

{
  Raises integer value Base to non-negative integer power Exponent and returns
  the result.
}
function Pow(const Base: Int64; const Exponent: Byte): Int64;
var
  I: Byte;
begin
  Result := 1;
  for I := 1 to Exponent do
    Result := Result * Base;
end;

{
  IEEE compliant function that raises real number X to the power N.
}
function PowN(const X: Extended; const N: Integer): Extended;
var
  I: Integer;
begin
  if N = 0 then
    // IEEE: pown(x, 0) is 1, even when X is zero
    Exit(1.0);
  if Math.SameValue(1.0, X) then
    Exit(1.0);
  if Math.IsZero(X) then
  begin
    if N < 0 then
      raise SysUtils.EDivByZero.Create('PowN: Negative exponent for X = 0');
    Exit(0.0);
  end;
  Result := 1.0;
  for I := 1 to System.Abs(N) do
    Result := Result * X;
  if N < 0 then
    Result := 1 / Result;
end;

{
  Raises integer X to non-negative integer power N.
  If the result is too large to be represented as an Int64 value then an
  EOverflow exception is raised.
}
function PowNZN(const X: Integer; const N: Cardinal): Int64;
var
  I: Integer;
  OverflowGuard: Int64;
begin
  if N = 0 then
    // IEEE: pown(x, 0) is 1, even when X is zero
    Exit(1);
  if X = 0 then
    // pown(0, n) = 0, for all positive n
    Exit(0);
  OverflowGuard := High(Int64) div Abs(X);
  Result := 1;
  for I := 1 to N do
  begin
    if OverflowGuard < Abs(Result) then
      raise SysUtils.EOverflow.CreateFmt(
        'Overflow calculating %d to the power %d', [X, N]
      );
    Result := Result * X;
  end;
end;

{
  Raises integer X to integer power N.
}
function PowNZZ(const X: Integer; const N: Integer): Extended;
var
  I: Integer;
  ResultInt: Int64;
begin
  if N = 0 then
    Exit(1.0);
  if X = 1 then
    Exit(1.0);
  if X = 0 then
  begin
    if N < 0 then
      raise SysUtils.EDivByZero.Create('PowNZZ: Negative exponent for X = 0');
    Exit(0.0);
  end;
  ResultInt := 1;
  for I := 1 to System.Abs(N) do
    ResultInt := ResultInt * X;
  if N > 0 then
    Result := ResultInt
  else // N < 0
    Result := 1 / ResultInt;
end;

{
  Returns the area of the given rectangle.
}
function RectArea(const R: Windows.TRect): Int64;
begin
  Result := Abs((R.Right - R.Left) * (R.Bottom - R.Top));
end;

{
  Returns the height of the given rectangle.
  The return value is always non-negative even if the rectangle is not
  normalized.
}
function RectHeight(const R: Windows.TRect): Integer;
begin
  Result := R.Bottom - R.Top;
  if Result < 0 then
    Result := -Result;
end;

{
  Returns the size of the given rectangle.
  The returned dimensions are always non-negative even if the rectangle is not
  normalized.
}
function RectSize(const R: Windows.TRect): Windows.TSize;
begin
  Result.cx := RectWidth(R);
  Result.cy := RectHeight(R);
end;

{
  Returns the width of the given rectangle.
  The return value is always non-negative even if the rectangle is not
  normalized.
}
function RectWidth(const R: Windows.TRect): Integer;
begin
  Result := R.Right - R.Left;
  if Result < 0 then
    Result := -Result;
end;

{
  Checks if the given integer contains only a single repeated digit.
}
function RepeatedDigits(N: Int64): Boolean;
begin
  N := Abs(N);
  if N > 0 then
    Result :=
      N = SysUtils.StrToInt64(
        StringOfChar(
          Char(48 + N mod 10),
          Succ(Math.Floor(Math.Log10(N)))
        )
      )
  else
    Result := True;
end;

{
  Resizes rectangle R to size NewSize, leaving the top-left position unchanged.
  Returns the resized rectangle.
}
function ResizeRect(const R: Types.TRect; const NewSize: Types.TSize):
  Types.TRect; overload;
begin
  Result := ResizeRect(R, NewSize.CX, NewSize.CY);
end;

{
  Resizes rectangle R to the width and height given by NewWidth and NewHeight,
  leaving the top-left position unchanged.
  Returns the resized rectangle.
}
function ResizeRect(const R: Types.TRect; const NewWidth, NewHeight: LongInt):
  Types.TRect; overload;
begin
  Result := Types.Bounds(R.Left, R.Top, NewWidth, NewHeight);
end;

{
  Reverses the digits of integer AValue and returns the resulting value.
  AValue should be positive: zero is always returned for negative integers.
}
function ReverseNumber(AValue: Int64): Int64;
begin
  Result := 0;
  while AValue > 0 do
  begin
    Result := (Result * 10) + (AValue mod 10);
    AValue := AValue div 10;
  end;
end;

{
  Reverses the digits of the given integer, which must be non-negative, and
  returns the resulting value.
  Uses recursion.
}
function ReverseNumberR(AValue: Int64): Int64;
begin
  Assert(AValue >= 0);
  if AValue mod 10 = AValue then
    Result := AValue
  else
    Result := ((AValue mod 10) * Trunc(IntPower(10, Trunc(Log10(AValue)))))
      + ReverseNumberR(AValue div 10)
end;

{
  Performs an arithmetic right shift operation on the given value and returns
  the result. Value is shifted right by Shift bits.
  Shift must be in the range 0..31 and is adjusted if it is not.
}
function SAR(Value: LongInt; Shift: Byte): LongInt;
begin
  Shift := Shift and 31;
  if Shift = 0 then
  begin
    Result := Value;
    Exit;
  end;
  Result := LongInt(LongWord(Value) shr Shift);
  if Value < 0 then
    Result := LongInt(LongWord(Result) or ($FFFFFFFF shl (32 - Shift)));
end;

{
  Scales the given rectangle by the given scale factor and returns the scaled
  rectangle.
}
function ScaleRect(const ARect: Types.TRect; AScaling: Double): Types.TRect;
begin
  Result.Left := System.Round(ARect.Left * AScaling);
  Result.Top := System.Round(ARect.Top * AScaling);
  Result.Right := System.Round(ARect.Right * AScaling);
  Result.Bottom := System.Round(ARect.Bottom * AScaling);
end;

{
  Returns the sign of the given floating point value. Returns -1 if the value is
  positive, 0 if zero or +1 if negative.
}
function SignOfFloat(const Value: Extended): Integer;
begin
  if Value < 0.0 then
    Result := -1
  else if Value = 0.0 then
    Result := 0
  else
    Result := 1;
end;

{
  Returns the sign of the given integer. Returns -1 if the integer is positive,
  0 if zero or +1 if negative.
}
function SignOfInt(const Value: Int64): Integer;
begin
  if Value < 0 then
    Result := -1
  else if Value = 0 then
    Result := 0
  else
    Result := 1;
end;

{
  Simplifies the fraction with numerator Num and denominator Denom to its lowest
  terms.
  If the fraction is already in its lowest terms then Num and Denom are left
  unchanged.
}
procedure SimplifyFraction(var Num, Denom: Int64);
var
  CommonFactor: Int64;  // greatest common factor of Num and Denom
begin
  Assert(Denom <> 0);
  CommonFactor := Abs(GCD(Num, Denom));
  Num := Num div CommonFactor;
  Denom := Denom div CommonFactor;
end;

{
  Stretches rectangle R by the given scaling factors and returns the result.
  The rectangle's width is scaled by ScalingX and its height by ScalingY.
  The top left corner of the rectangle is not changed.
}
function StretchRect(const R: Types.TRect; const ScalingX, ScalingY: Double):
  Types.TRect; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sErrorMsg = 'StretchRect(): Rectangle bottom or right out of bounds.';
var
  NewW, NewH: Double;  // stretched width and height of rectangle
begin
  NewW := (R.Right - R.Left) * ScalingX;
  NewH := (R.Bottom - R.Top) * ScalingY;
  if (Abs(NewW + R.Left) > High(LongInt))
    or (Abs(NewH + R.Top) > High(LongInt)) then
    raise SysUtils.EOverflow.Create(sErrorMsg);
  Result := Types.Bounds(R.Left, R.Top, System.Round(NewW), System.Round(NewH));
end;

{
  Stretches the rectangle R by scale factor Scaling and returns the result. Both
  width and height are stretched by the same scale factor.
  The top left corner is not changed.
}
function StretchRect(const R: Types.TRect; const Scaling: Double):
  Types.TRect; overload;
begin
  Result := StretchRect(R, Scaling, Scaling);
end;

{
  Returns the sum of the natural logarithms of each Cardinal element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Cardinal): Extended; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Cardinal;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Elem = 0 then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each Double floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Double): Double; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Double;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Math.Sign(Elem) <> Math.PositiveValue then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each Extended floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Extended): Extended; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Extended;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Math.Sign(Elem) <> Math.PositiveValue then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each Int64 element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Int64): Extended; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Int64;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Elem <= 0 then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each Integer element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of Integer): Extended; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Integer;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Elem <= 0 then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each Single floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Single): Single; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Single;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Math.Sign(Elem) <> Math.PositiveValue then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Returns the sum of the natural logarithms of each UInt64 element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0 is returned if A is empty.
}
function SumOfLogs(const A: array of UInt64): Extended; overload;
{$IFDEF FPC}
const
{$ELSE}
resourcestring
{$ENDIF}
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: UInt64;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Elem = 0 then
      raise SysUtils.EArgumentOutOfRangeException(sNotPositive);
    Result := Result + System.Ln(Elem);
  end;
end;

{
  Calculates and returns the weighted average of the Cardinal elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Cardinal;
  const Weights: array of Double): Double; overload;
var
  Idx: Integer;
  DblVals: array of Double;
begin
  SetLength(DblVals, Length(Values));
  for Idx := Low(Values) to High(Values) do
    DblVals[Idx] := Values[Idx];
  Result := WeightedArithMean(DblVals, Weights);
end;

{
  Calculates and returns the weighted average of the Double elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;
var
  WeightSum: Double;
  Weight: Double;
  Idx: Integer;
begin
  if Length(Values) = 0 then
    raise SysUtils.EArgumentException.Create('Array of values is empty');
  if Length(Values) <> Length(Weights) then
    raise SysUtils.EArgumentException.Create(
      'Number of values and number of weights must be the same'
    );
  WeightSum := 0.0;
  for Weight in Weights do
  begin
    if Math.Sign(Weight) = Math.NegativeValue then
      raise SysUtils.EArgumentException.Create('Weights must all be >= 0');
    WeightSum := WeightSum + Weight;
  end;
  if Math.IsZero(WeightSum) then
    raise SysUtils.EArgumentException.Create('All weights are 0');
  Result := 0.0;
  for Idx := Low(Values) to High(Values) do
    Result := Result + Weights[Idx] * Values[Idx] / WeightSum;
end;

{
  Calculates and returns the weighted average of the Integer elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithMean(const Values: array of Integer;
  const Weights: array of Double): Double; overload;
var
  Idx: Integer;
  DblVals: array of Double;
begin
  SetLength(DblVals, Length(Values));
  for Idx := Low(Values) to High(Values) do
    DblVals[Idx] := Values[Idx];
  Result := WeightedArithMean(DblVals, Weights);
end;

{
  Calculates and returns the largest scaling that can be applied to a rectangle
  of width SrcWidth and height SrcHeight to fit it, without changing the aspect
  ratio, within a second rectangle of width DestWidth and height DestHeight.
}
function ZoomRatio(const DestWidth, DestHeight, SrcWidth, SrcHeight: Integer):
  Double; overload;
begin
  Result := Math.Min(DestWidth / SrcWidth, DestHeight / SrcHeight);
end;

{
  Calculates and returns the largest scaling that can be applied to a rectangle
  of size SrcSize to fit it, without changing the aspect ratio, within a second
  rectangle of size DestSize.
}
function ZoomRatio(const DestSize, SrcSize: Types.TSize): Double; overload;
begin
  Result := ZoomRatio(DestSize.cx, DestSize.cy, SrcSize.cx, SrcSize.cy);
end;

{
  Calculates and returns the largest scaling that can be applied to rectangle
  SrcRect to fit it, without changing the aspect ratio, within rectangle
  DestRect.
}
function ZoomRatio(const DestRect, SrcRect: Types.TRect): Double; overload;
begin
  Result := ZoomRatio(RectSize(DestRect), RectSize(SrcRect));
end;

end.
